[{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://jcunow.github.io/RootScanR/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"flatbed-root-scan-analysis-trait-extraction-and-quantification","dir":"Articles","previous_headings":"","what":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Flatbed scanning allows capture root morphology 2D plane. RootScanR provides suite tools processing flatbed images roots, including trait extraction, root length measurement, morphology analysis. vignette guide extracting root traits flatbed scans help quantify root systems various ecological studies.","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"installation","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans","what":"Installation","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"","code":"# Install the package from GitHub # install.packages(\"remotes\") # remotes::install_github(\"jcunow/RootScanR\")  # Load the package library(RootScanR) library(tidyverse)  # For data manipulation and visualization"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"key-functionalities-for-flatbed-scan-analysis","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans","what":"Key Functionalities for Flatbed Scan Analysis","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"working flatbed scans, RootScanR offers primary functions: Image Pre-processing: Convert prepare images analysis Skeletonization: Create single-pixel-wide representation root structures Root Trait Extraction: Calculate key morphological traits (length, diameter, density) Architectural Analysis: Assess root system complexity structure","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"loading-images","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow","what":"1. Loading Images","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Import flatbed scan images analysis.","code":"# Load a flatbed scan image (replace with your actual file path) flatbed_image <- load_flexible_image(   \"path/to/flatbed_scan.tiff\",    verbose = TRUE )  # Display the image plot(flatbed_image, main = \"Original Flatbed Scan\")"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"image-pre-processing","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow","what":"2. Image Pre-processing","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Prepare image analysis converting binary format needed.","code":"# Convert to binary image if not already binary # (skip this step if your image is already properly segmented) binary_image <- RootScanR::image_threshold   flatbed_image,   threshold = 0.4,  # or specify a threshold value   select.layer = 2,     method = \"global\",   binary_01 = TRUE )  # Display binary image plot(binary_image, main = \"Binary Root Image\")"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"skeletonization","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow","what":"3. Skeletonization","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Create single-pixel-wide representation root system morphological analysis.","code":"# Skeletonize the root image skeleton <- skeletonize_roots(   binary_image,   method = \"MAT\",           # Medial Axis Transform   output_format = \"spatrast\" # Return as a SpatRaster object )  # Visualize the skeleton plot(skeleton, main = \"Root Skeleton\")"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"root-trait-extraction","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow","what":"4. Root Trait Extraction","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Calculate quantitative metrics describe root system morphology.","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"branching-structure","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow > 4. Root Trait Extraction","what":"4.1 Branching Structure","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Identify key structural elements root system.","code":"# Detect root tips and branching points skeleton_features <- detect_skeleton_points(skeleton)  # Count root tips (endpoints) root_tips <- count_pixels(skeleton_features$endpoints) print(paste0(\"Number of root tips: \", root_tips))  # Count branching points branching_points <- count_pixels(skeleton_features$branching_points) print(paste0(\"Number of branching points: \", branching_points))  # Calculate branching frequency branching_frequency <- branching_points / calculate_root_length(skeleton) * 100 print(paste0(\"Branching frequency (per 100 cm): \", round(branching_frequency, 2)))"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"root-length","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow > 4. Root Trait Extraction","what":"4.2 Root Length","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Calculate total length roots image.","code":"# Calculate root length using Kimura's method root_length <- root_length(skeleton) print(paste0(\"Total root length (cm): \", round(root_length, 2)))"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"root-coverage-and-density-conversion","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow > 4. Root Trait Extraction","what":"4.3 Root Coverage and Density Conversion","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Assess much scan area occupied roots.","code":"# Create background (non-root) mask background <- (binary_image - 1) * -1  # Count root and background pixels root_pixels <- count_pixels(binary_image) background_pixels <- count_pixels(background)  # Calculate root density (proportion of area covered by roots) root_density <- root_pixels / (root_pixels + background_pixels) print(paste0(\"Root density: \", round(root_density, 4)))  # Calculate root length density (proportion of area covered by roots) rootlength_density <- root_length / (root_pixels + background_pixels) print(paste0(\"Root length density: \", round(rootlength_density, 4)))"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"root-diameter","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow > 4. Root Trait Extraction","what":"4.4 Root Diameter","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Estimate thickness roots different positions.","code":"# Calculate root diameters diameter_map <- root_diameter(   root_map,    select.layer = 2,   diagnostics = T,   skeleton_method = \"MAT\"  # Distance transform method )  # Get summary statistics of root diameters diameter_stats = data.frame(diameter_map$diameters) %>%   mutate(diameters =lyr.1) %>%   summarise(     mean = mean( diameters, na.rm = TRUE),     sd = sd(diameters, na.rm = TRUE),     median = median(diameters)   )  # or library(psych) diameter_stats <- describe(diameter_map$diameters) print(\"Root diameter statistics (mm):\") print(diameter_stats)  # Visualize diameter distribution h <- hist(   diameter_map$diameters,    main = \"Root Diameter Distribution\",   xlab = \"Diameter (mm)\",    plot = FALSE )   plot(h$mids, h$counts, type = \"h\", lwd = 10, col = \"lightblue\",      log = \"y\", xlab = \"Log-scaled Data\", ylab = \"Counts\",      main = \"Histogram with Log-Scaled Y-Axis\")"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"visualization-and-export","dir":"Articles","previous_headings":"Analyzing Root Systems from Flatbed Scans > Example Workflow","what":"5. Visualization and Export","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"Purpose: Create visual representations results export data analysis.","code":"library(grid) # overlay plotting g1 = ggplotGrob(flatbed_image) g2 = ggplotGrob(skeleton)  grid.draw(g1) grid.draw(g2)  # Export results to CSV export_results <- data.frame(   sample_id = \"example_scan\",   total_length_cm = root_length,   root_tips = root_tips,   branching_points = branching_points,   branching_frequency = branching_frequency,   mean_diameter_mm = diameter_stats$mean,   root_density = root_density )  write.csv(export_results, \"flatbed_scan_results.csv\", row.names = FALSE)"},{"path":"https://jcunow.github.io/RootScanR/articles/FlatBedScans_vignettes.html","id":"section","dir":"Articles","previous_headings":"","what":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","title":"Analyzing Root Traits from Flatbed Scans with RootScanR in R","text":"detailed information specific functions additional features, please refer function documentation package GitHub repository https://github.com/jcunow/RootScanR.","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"introduction","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR","what":"Introduction","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"vignette demonstrates analyze minirhizotron scans using RootScanR package. Minirhizotrons transparent tubes inserted soil observe root growth via scanning imaging technology. RootScanR designed comprehensive analysis root system images, providing tools image preparation, depth mapping, extraction meaningful root traits. extract root traits, segmenting image outside R needed (see step 2).","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"key-functionalities","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR","what":"Key Functionalities","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"typical workflow analyze minirhizotron scans look something like following. Step 2 step 3 depend Image Stitching: Combine sequential minirhizotron images create complete tube scans AI-Based Image Segmentation: Work images segmented dedicated root detection software -situ Calibration: Needed accurately map image pixels soil depth. alternative shown requires special attention Depthmap Creation: Generate depth information pixel root scans Root Trait Extraction: Calculate important root metrics (length, density, branching, etc.) Spatial Root Features Extracting spatial-explicit root scape features e.g., entropy, root instance count, fractal dimension Soil Characterization: Analyze soil/peat properties scan images","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"installation","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR","what":"Installation","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"","code":"# Install the package from GitHub # install.packages(\"remotes\") # remotes::install_github(\"jcunow/RootScanR\")  # Load the package library(RootScanR) library(tidyverse)  # For data manipulation and visualization library(terra)      # For raster image handling"},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"image-stitching","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"1. Image Stitching","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Combine multiple sequential images longer minirhizotron tubes single composite image enable proper depth alignment remove overlap images.","code":"# Load example image files (replace with your actual file paths) image_files <- c(\"path/to/image1.png\", \"path/to/image2.png\", \"path/to/image3.png\")  # Stitch images together (removes redundant overlap) stitched_image <- RootScanR::stitch_sequential_images(image_files,                                                        overlap_px = 200,                                                        method = \"crosscorr\",                                                       side1 = \"bottom\")     # Visualize the stitched image plot(stitched_image, main = \"Stitched Minirhizotron Image\")"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"image-segmentation-recommendations","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"2. Image Segmentation Recommendations","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Separate roots background minirhizotron images. RootScanR works segmented images perform segmentation . recommend using specialized tools: Returns segmented skeletonized images different information channels Can distinguish tape, roots, background Supports root tracking production, decay, turnover analysis Reference: Peters et al. (2023), Scientific Reports 13(1) Returns segmented images Uses interactive deep learning improved segmentation Reference: Smith et al. (2022), New Phytologist 236(2) Tip: images high root density, consider splitting stitched images segmentation rejoining afterwards. Tip: Models can sensitive resolution. Try","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"loading-images","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"3. Loading Images","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Import segmented original RGB images analysis.","code":"# Load a segmented image (replace with your file path). The function accepts multiple different input formats. segmented_image <- load_flexible_image(\"path/to/segmented_image.tif\", output_format = \"spatrast\", normalize = F, select.layer = NULL, binarize = FALSE)  # Load corresponding RGB image for visual reference rgb_image <- load_flexible_image(\"path/to/rgb_image.tif\", output_format = \"spatrast\")  # Display the images plot(rgb_image, main = \"Original RGB Image\") plot(segmented_image, main = \"Segmented Image\")"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"tube-calibration","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"4. Tube Calibration","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Establish relationship image pixels actual soil depth. -situ calibration highly recommended accurate depth attribution. calibration data unavailable, RootScanR provides estimation functions using tape cover proxy:","code":"# Estimate soil surface position based on tape cover. Here, 0.5 cm of tape beyond the true soil surface is assumed to block out light. soil_surface <- estimate_soil_surface(rgb_image, dpi = 300, tape.overlap = 0.5) print(paste0(\"Estimated soil surface begins at column: \", soil_surface$soil0))  # Estimate rotation center. This only works for asymmetric taping around the tube with more on the uside.  rotation_center <- estimate_rotation_center(rgb_image) print(paste0(\"Estimated rotation center at row: \", rotation_center))"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"depthmap-creation","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"5. Depthmap Creation","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Create map assigns soil depth values pixel image.","code":"# Create a mask to exclude tape from soil analysis # Assuming RootDetector format where red channel includes tape tape_mask <- (segmented_image[[1]] - segmented_image[[2]]) / 255 tape_mask <- terra::t(tape_mask)  # Calculate normalized rotation center position center_offset <- rotation_center / dim(segmented_image)[1]  # Create the depthmap depth_map <- create_depthmap(   image = segmented_image,    sinusoidal = TRUE,    # Account for tube curvature   mask = tape_mask,   soil_start = soil_surface,   center_offset = center_offset )  # Visualize the depthmap plot(depth_map, main = \"Depth Map\")"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"depth-binning","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"6. Depth Binning","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Group depths discrete intervals statistical analysis visualization.","code":"# Create depth bins (5cm intervals) binned_map <- bin_depths(depth_map, interval = 5, method = \"rounding\")  # Correct extent for plotting terra::ext(binned_map) <- c(0, dim(binned_map)[2], 0, dim(binned_map)[1])  # Visualize binned depthmap transposed_map <- terra::t(binned_map) terra::plot(transposed_map, main = \"Binned Depth Map (5cm intervals)\")"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"root-skeletonization","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"7. Root Skeletonization","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Create single-pixel-wide representation root structure morphological analysis.","code":"# Create root skeleton using Medial Axis Transform (MAT) method # Select layer 2 which typically contains root information in RootDetector output skeleton <- skeletonize_image(   segmented_image,    method = \"MAT\",    select.layer = 2,   verbose = TRUE )  # Visualize skeleton plot(skeleton, main = \"Root Skeleton\")"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"root-trait-extraction","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"8. Root Trait Extraction","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Calculate quantitative root system traits ecological analysis.","code":"# Detect endpoints and branching points skeleton_points <- detect_skeleton_points(skeleton) root_tips <- px.sum(skeleton_points$endpoints) branching_points <- px.sum(skeleton_points$branching_points) print(paste0(\"Number of root tips: \", root_tips)) print(paste0(\"Number of branching points: \", branching_points))  # Calculate root length using Kimura's method root_length <- RootLength(skeleton) print(paste0(\"Total root length (cm): \", root_length))  # Calculate root density # Create binary mask of non-root area void_area <- (prepare_binary_image(segmented_image) - 1) * -1 root_pixels <- px.sum(segmented_image, layer = 2) void_pixels <- px.sum(void_area, layer = 2) root_density <- root_pixels / (root_pixels + void_pixels) print(paste0(\"Root density: \", round(root_density, 3)))  # Calculate maximum rooting depth (\"deep drive\") deep_drive <- deep_drive(   RootMap = segmented_image,    DepthMap = depth_map ) print(paste0(\"Maximum rooting depth (cm): \", deep_drive))  # Calculate landscape metrics for root architecture root_metrics <- root_scape_metrics(   img = segmented_image,    indexD = 5,    metrics = c(\"lsm_c_ca\", \"lsm_l_ent\", \"lsm_c_pd\", \"lsm_c_enn_mn\") ) print(\"Root architecture metrics:\") print(root_metrics)"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"soilpeat-characterization","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"9. Soil/Peat Characterization","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Analyze soil properties visible minirhizotron images.","code":"# Analyze overall tube color tube_color <- tube_coloration(rgb_image) print(\"Overall tube color metrics:\") print(tube_color)  # Create buffer around roots to analyze soil without root & rhizosphere influence root_buffer <- create_root_buffer(segmented_image, width = 2, halo.only = FALSE)  # Create soil-only image by removing root areas soil_image <- rgb_image - root_buffer  # Analyze soil color soil_color <- tube_color(soil_image) print(\"Soil color metrics:\") print(soil_color)  # Extract soil texture information using GLCM (Gray-Level Co-occurrence Matrix) gray_image <- rgb2gray(soil_image) soil_texture <- analyze_soil_texture(   gray_image,   gray_levels = 7,   window_size = c(3, 3),   statistics = c(\"second_moment\", \"homogeneity\"),   directions = list(c(0, 1), c(1, 1), c(1, 0), c(1, -1)) ) print(\"Soil texture metrics:\") print(soil_texture)"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"depth-based-analysis","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR > Example Workflow","what":"10. Depth-Based Analysis","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"Purpose: Analyze root traits change soil depth.","code":"## create analytical zones; indexD indicates which depth to look at. root_zone = zone.fun(rootpic = root_map,                       indexD = 10,                      binned.map =  binning(depthmap = depth_map, 5) )  # go through each slice bin_width = 2 rl.df  = data.frame(depth = seq(0,30,bin_width), rl = NA,rl.density = NA, rootpx = NA, voidpx = NA) root_map =  load_flexible_image(root_map,binarize = TRUE, output_format = \"spatrast\") for(i in rl.df$depth){   # analytical unit   root_zone = zone.fun(rootpic = root_map ,                       indexD = i,                      binned.map =  binning(depthmap = depth_map, bin_width) )   # root length   try(rl.df$rl[rl.df$depth == i] <- as.numeric(root_length(root_zone,dpi = 150)))        # available root pixels   try(rl.df$rootpx[rl.df$depth == i] <-  as.numeric(px.sum(root_zone)))     # available soil & tape pixels (inverse roots)     voidpx <- abs(root_zone -1)   try(rl.df$voidpx[rl.df$depth == i] <- as.numeric(px.sum(voidpx)))     # calculate rootlength density   try(rl.df$rl.density[rl.df$depth == i] <- as.numeric(rl.df$rl[rl.df$depth == i] / (rl.df$rootpx[rl.df$depth == i] + rl.df$voidpx[rl.df$depth == i])))    }   # Visualize results ggplot(rl.df, aes(x = depth, y = scale(rl.density))) +   geom_line() +   geom_point() +   geom_line(aes(y = scale(rootpx)),color = \"steelblue4\") +   geom_point(aes(y = scale(rootpx)),color=\"steelblue4\") +     geom_line(aes(y = scale(voidpx+rootpx)/10),color=\"darkorange\") +   geom_point(aes(y = scale(voidpx+rootpx)/10),color=\"darkorange\") +   theme_minimal() +   labs(     title = \"Root Length by Soil Depth\",     x = \"Soil Depth (cm)\",     y = \"standard deviation\"   )"},{"path":"https://jcunow.github.io/RootScanR/articles/MinirhizotronScans_vignettes.html","id":"conclusion","dir":"Articles","previous_headings":"Minirhizotron Scans Analysis with RootScanR","what":"Conclusion","title":"Minirhizotron Scans Analysis with RootScanR in R","text":"vignette demonstrates core workflows analyzing minirhizotron images RootScanR. detailed information specific functions additional features, please refer function documentation package GitHub repository https://github.com/jcunow/RootScanR.","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"introduction","dir":"Articles","previous_headings":"Rotation Bias Analysis","what":"Introduction","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"vignette demonstrates analyze rotation methodological bias minirhizotron setup using RootScanR package. minirhizotron studies, roots may exhibit preferential growth areas tube surface depending tube size tube insertion angle. might also affect roots behave surface e.g., changing root growth angles.","code":""},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"installation","dir":"Articles","previous_headings":"Rotation Bias Analysis","what":"Installation","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"","code":"# Install the package from GitHub # install.packages(\"remotes\") # remotes::install_github(\"jcunow/RootScanR\")  # Load the package library(RootScanR) library(ggplot2)  # For enhanced plotting"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"key-functionalities","dir":"Articles","previous_headings":"Rotation Bias Analysis","what":"Key Functionalities","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"rotation bias circadian analysis module includes: Sine Curve Fitting: Model circadian rhythms root growth data Statistical Testing: Assess significance observed rhythmic patterns Bias Quantification: Calculate metrics directional growth preferences Visualization Tools: Create informative plots temporal patterns","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"preparing-time-series-data","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"1. Preparing Time-Series Data","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Organize time-series observations root growth analysis.","code":"# Example: Loading time-series data # In a real scenario, you would load your own data from files # The data should contain timestamps and root measurements  # For demonstration, we'll generate synthetic data set.seed(32608)  # For reproducibility period <- 24     # 24-hour cycle n <- 50          # Number of observations timestamps <- runif(n, 0, 3*period)  # Random sampling times across 3 days amplitude <- 2   # Strength of the rhythm phase <- 6       # Time offset (hours) baseline <- 3    # Average growth rate noise <- 1       # Random variation  # Simulate root growth with circadian pattern growth_rates <- amplitude * sin(2 * pi / period * (timestamps + phase)) +                  baseline + rnorm(n, 0, noise)  # Create a data frame for analysis root_ts_data <- data.frame(   time = timestamps,   growth_rate = growth_rates )  # Visualize the raw time-series data ggplot(root_ts_data, aes(x = time, y = growth_rate)) +   geom_point() +   labs(     title = \"Root Growth Rate Time Series\",     x = \"Time (hours)\",     y = \"Growth Rate (mm/hour)\"   ) +   theme_minimal()"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"fitting-circadian-models","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"2. Fitting Circadian Models","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Detect characterize circadian rhythms root growth patterns.","code":"# Fit a sine curve to the time-series data circadian_fit <- fit_circadian_model(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   period = 24,  # Fixed 24-hour period   method = \"nls\" # Non-linear least squares )  # Display model parameters print(\"Circadian model parameters:\") print(circadian_fit$parameters)  # Plot the data with fitted curve plot_circadian_fit(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   fit = circadian_fit,   title = \"Circadian Rhythm in Root Growth\" )"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"statistical-testing-for-rhythmicity","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"3. Statistical Testing for Rhythmicity","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Determine observed patterns statistically significant circadian rhythms.","code":"# Perform statistical tests to validate circadian rhythms  # 1. Wald Test (tests if amplitude is significantly different from zero) wald_result <- test_circadian_wald(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   period = 24 ) print(\"Wald test for circadian rhythmicity:\") print(wald_result)  # 2. Likelihood Ratio Test (compares rhythmic vs. constant models) lr_result <- test_circadian_lr(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   period = 24 ) print(\"Likelihood Ratio test for circadian rhythmicity:\") print(lr_result)  # 3. F Test (tests overall model significance) f_result <- test_circadian_f(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   period = 24 ) print(\"F test for circadian rhythmicity:\") print(f_result)"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"period-analysis","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"4. Period Analysis","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Identify dominant period root growth patterns period unknown.","code":"# Scan for the most likely period in the data period_scan <- analyze_circadian_period(   time = root_ts_data$time,   values = root_ts_data$growth_rate,   period_range = c(12, 36),  # Test periods between 12 and 36 hours   step = 0.5                 # Step size in hours )  # Plot period scan results plot_period_scan(   period_scan,   title = \"Period Analysis of Root Growth\" )  # Identify the best-fitting period best_period <- period_scan$period[which.min(period_scan$residual_sum_squares)] print(paste0(\"Best-fitting period: \", round(best_period, 2), \" hours\"))"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"rotation-bias-analysis-1","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"5. Rotation Bias Analysis","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Quantify directional preferences root growth around minirhizotron tubes.","code":"# For rotation bias, we need data that includes angular positions # In a minirhizotron, this would be the angular position around the tube  # For demonstration, we'll generate synthetic rotation data set.seed(42) n_roots <- 100 angular_positions <- runif(n_roots, 0, 360)  # Angles in degrees  # Simulate a bias toward the bottom of the tube (180 degrees) bias_center <- 180 bias_strength <- 0.5 density <- bias_strength * dnorm(angular_positions, bias_center, 45) +             (1 - bias_strength) * dunif(angular_positions, 0, 360)             # Normalize to create a probability of root presence probability <- density / sum(density) * n_roots root_counts <- rpois(n_roots, probability)  # Create a data frame for analysis rotation_data <- data.frame(   angle = angular_positions,   root_count = root_counts )  # Analyze rotation bias rotation_bias <- analyze_rotation_bias(   angles = rotation_data$angle,   values = rotation_data$root_count,   bins = 24  # Number of angular bins )  print(\"Rotation bias metrics:\") print(rotation_bias$metrics)  # Visualize rotation bias plot_rotation_bias(   rotation_bias,   title = \"Root Growth Rotation Bias\" )"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"combined-temporal-and-directional-analysis","dir":"Articles","previous_headings":"Rotation Bias Analysis > Example Workflow","what":"6. Combined Temporal and Directional Analysis","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Investigate rotation bias changes circadian rhythms.","code":"# For this analysis, we need data that combines time and angular position # Generate synthetic data for demonstration  # Create time points across 3 days time_points <- seq(0, 72, by = 3) n_times <- length(time_points)  # Create angular positions angle_points <- seq(0, 345, by = 15) n_angles <- length(angle_points)  # Create a matrix of root counts with time-dependent rotation bias root_matrix <- matrix(0, nrow = n_times, ncol = n_angles) colnames(root_matrix) <- angle_points rownames(root_matrix) <- time_points  # Simulate time-varying bias for (i in 1:n_times) {   time <- time_points[i]      # Bias center shifts over time (simulating heliotropism)   bias_center <- (180 + 45 * sin(2 * pi * time / 24)) %% 360      # Generate root counts with the time-dependent bias   for (j in 1:n_angles) {     angle <- angle_points[j]     distance <- min(abs(angle - bias_center), 360 - abs(angle - bias_center))     root_matrix[i, j] <- rpois(1, lambda = 5 * exp(-distance^2/1000) + 1)   } }  # Analyze time-dependent rotation bias temporal_bias <- analyze_temporal_rotation_bias(   root_matrix = root_matrix,   time_points = time_points,   angle_points = angle_points,   period = 24 )  print(\"Temporal rotation bias results:\") print(temporal_bias$summary)  # Visualize time-dependent rotation bias plot_temporal_bias(   temporal_bias,   title = \"Time-Dependent Root Growth Direction\" )"},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"comparing-rotation-bias-between-treatments","dir":"Articles","previous_headings":"Rotation Bias Analysis > Advanced Applications","what":"Comparing Rotation Bias Between Treatments","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"Purpose: Determine different experimental treatments affect root directional preferences.","code":"# Simulate data for two treatments set.seed(123)  # Treatment 1: Strong downward bias angles_t1 <- rnorm(100, mean = 180, sd = 30) %% 360 counts_t1 <- rpois(100, lambda = 5)  # Treatment 2: Weaker, more diffuse bias angles_t2 <- rnorm(100, mean = 180, sd = 60) %% 360 counts_t2 <- rpois(100, lambda = 5)  # Analyze rotation bias for each treatment bias_t1 <- analyze_rotation_bias(angles_t1, counts_t1, bins = 24) bias_t2 <- analyze_rotation_bias(angles_t2, counts_t2, bins = 24)  # Compare bias strength statistically bias_comparison <- compare_rotation_bias(   bias_t1,    bias_t2,   method = \"rayleigh\" )  print(\"Bias comparison results:\") print(bias_comparison)  # Visualize the comparison plot_bias_comparison(   list(Treatment1 = bias_t1, Treatment2 = bias_t2),   title = \"Rotation Bias Comparison Between Treatments\" )"},{"path":"https://jcunow.github.io/RootScanR/articles/Rotation_Bias_vignettes.html","id":"conclusion","dir":"Articles","previous_headings":"Rotation Bias Analysis","what":"Conclusion","title":"Rotation Bias and Circadian Analysis with RootScanR","text":"vignette demonstrated analyze rotation bias circadian rhythms root growth using RootScanR package. analyses can reveal important aspects root growth strategies responses environmental cues light, gravity, daily temperature cycles. Key takeaways: 1. Circadian rhythms can detected characterized using sine curve fitting 2. Statistical tests help validate significance observed rhythms 3. Rotation bias analysis quantifies directional preferences root growth 4. Combined temporal directional analysis can reveal complex growth patterns detailed information specific functions additional features, please refer function documentation package GitHub repository https://github.com/jcunow/RootScanR.","code":""},{"path":"https://jcunow.github.io/RootScanR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Cunow. Author, maintainer.","code":""},{"path":"https://jcunow.github.io/RootScanR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cunow J (2025). RootScanR: Depth-Resolved Root Analysis Trait Extraction Minirhizotrons Flatbed Scanner. R package version 1.1.0, https://github.com/jcunow/RootScanR.","code":"@Manual{,   title = {RootScanR: Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner},   author = {Johannes Cunow},   year = {2025},   note = {R package version 1.1.0},   url = {https://github.com/jcunow/RootScanR}, }"},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"RootScanR package designed make analysis minirhizotron root scans just little less stupid. package relies prior Image segmentation. recommend using RootDetector RootPainter. packages enables user map various root features continue s depth distributions. user choice include tube insertion angle tube diameter - ignore (?). Rotational bias root prevalence can tested. Let know questions, improvements, found bugs & errors.","code":"# install the package if (!require(\"devtools\")) {   install.packages(\"devtools\") } devtools::install_github(\"jcunow/RootScanR\")"},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"calibration","dir":"","previous_headings":"","what":"Calibration","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"accurate results require easy gather -situ calibration tube. Traditionally, assumption tube installed perfectly, .e., exact insertion angle, insertion depth, scanner rotation position, tape overshoot tube. RootScanR offers possibility approximate soil start rotation center based assumption well-taped tubes. Soil Surface Position Estimation Scanner Rotation Position, Rotation Differences Two Scans, Removal Scan Edges present one Scan .","code":"start.soil = SoilSurfE(img) RotationE(img) RotShiftDet(img1,img2) RotCensor(img,center.offset = 0.3,fixed.rotation = FALSE)  # under construction: estimating rotation by root distribution (assuming top-tube bias) LR_rhythmicity(rotation.cuts, root.px, period= number.rotation.slices)$phase * (dim(roation.cuts)[1]/number.rotations.slices) %>% round()"},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"the-core-function-create-a-depthmap","dir":"","previous_headings":"","what":"The core function: Create a depthmap","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"requires: soil surface estimate, rotation center estimate, tube insertion angle, tube diameter, scan resolution Phase shifted, trimmed sine depth mapping including tube diameter tube insertion angle","code":"depthmap = create_depthmap(img,mask, tube.thicc = 7, tilt = 45, dpi = 300, start.soil = 0,center.offset = 0)"},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"zoning---create-analytical-units","dir":"","previous_headings":"","what":"Zoning - Create analytical units","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"Creates discrete sub-units whole image. determines resolution depth distributions. Currently, package supports analysis within discrete depth bands. Future releases tackle response functions continuous depth. Depth-wise zoning","code":"binned.map = binning(depthmap, nn = 1,\"rounding\") root.zone = zone.fun(img, binned.map, indexD = 5, nn = 1)"},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"feature-extractions","dir":"","previous_headings":"","what":"Feature Extractions","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"Parameter segmented image cut Parameter skeletonized image cut Combine Parameter RGB image cut Turnover - either two images different time points, ‘RootDetector’ root tracking output","code":"RootScapeMetrics(root.zone, metrics = c(\"lsm_c_ca\",\"lsm_c_pland\",\"lsm_c_enn_mn\")) Root.px = count_pixel(root.zone) root.zone.skl = skeletonize_image(root.zone, method = \"MAT\", layer = 2) RL = root_length(root.zone.skeleton) root.thickness(Root.px, RL) Rhizosphere = Halo(root.zone, width = 5, halo.only = FALSE) soil = rgb.img[Rhizosphere == 1] < - NA analyze_soil_texture(soil) soil.color = tube_coloration(soil) turnover_tc(root.zone1,root.zone2, method = \"kimura\",dpi = 300, unit = \"cm\") turnover_dpc(root.zone.dpc, product.layer = 2, decay.layer = 1, im.return = F)"},{"path":"https://jcunow.github.io/RootScanR/index.html","id":"rotational-bias","dir":"","previous_headings":"","what":"Rotational Bias","title":"Depth-Resolved Root Analysis and Trait Extraction from Minirhizotrons and Flatbed Scanner","text":"Rotational zoning, Feature Extraction, Test Amplitude Difference Can used text e.g., differences top-bottom-tube bias varying insertion angle tube diameter test differences sinus fits, make use diffCircadian package https://github.com/diffCircadian/diffCircadian","code":"rotation.rootpx = data.frame(kk = 1:12,px = NA)  for(i in rotation.rootpx){ rotation.zone = zone.rotation.fun(img,k = c(i-1,i),kk = 12, mm = c(1500,5000)) rotation.rootpx$px[i,] = count_pixel(rotation.zone) } fitSinCurve(rotation.rootpx$px,period = 12) LTTest_diff_amp(img1_rotation.rootpx$px,img2_rotation.rootpx$px)"},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":null,"dir":"Reference","previous_headings":"","what":"F test for detecting circadian pattern — FTest","title":"F test for detecting circadian pattern — FTest","text":"Test significance circadian curve fitting using F test.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"F test for detecting circadian pattern — FTest","text":"","code":"FTest(tt, yy, period = 24)"},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"F test for detecting circadian pattern — FTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"F test for detecting circadian pattern — FTest","text":"list amp, phase, offset, peak, SST, SSE, R2. Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) offset Basal level(vertical shift) based formula 1 formula 2 tss Total sum square rss Residual sum square, SSE/n MLE variance sigma2 R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"F test for detecting circadian pattern — FTest","text":"sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"F test for detecting circadian pattern — FTest","text":"Caleb (Zhiguang Huo)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/FTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"F test for detecting circadian pattern — FTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) FTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $offset #> [1] 3.028329 #>  #> $rss #> [1] 27.31912 #>  #> $tss #> [1] 125.0438 #>  #> $R2 #> [1] 0.7815237 #>  #> $df1 #> [1] 2 #>  #> $df2 #> [1] 47 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>"},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Test significance circadian curve fitting using finite sample likelihood ratio test","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"","code":"LRTest(tt, yy, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"list amp, phase, offset, sigma02, sigmaA2, l0, l1, df, stat, pvalue. model: \\(y= * sin(2*pi*x+B)+C\\) y 1*n vector data y estimated ^hat fitCurve B estimated B^hat fitCurve C estimated C^hat fitCurve sigma0 sigma0^hat H0 sigmaA sigmaA^hat H1 n length data y df0 df H0 df1 df H1 amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level(vertical shift) based formula 1 formula 2 sigma02 Variance estimate null (intercept ) sigmaA2 Variance estimate alternative (since curve fitting) l0 Log likelihood null (intercept ) l1 Log likelihood alternative (since curve fitting) df Degree freedom LR test stat LR statistics pvalue P-value LR test R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Caleb (Zhiguang Huo)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LRTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) LRTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>"},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"Test significance circadian curve fitting using likelihood-based tests.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"","code":"LR_rhythmicity(tt, yy, period = 24, method = \"LR\", FN = TRUE)"},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"tt Time vector yy Expression vector period Period since curve. Default 24. method Testing methods can \"Wald\" \"LR\". Default \"LR\". FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"list amp, phase, offset, sigma02, sigmaA2, l0, l1, df, stat, pvalue. Formula 1: \\(yy = amp * sin(2\\pi/period * (phase + tt)) + offset\\) Formula 2: \\(yy = * sin(2\\pi/period * tt) + B * cos(2*\\pi/period * tt) + offset\\) amp Amplitude based formula 1. phase Phase based formula 1, phase restricted within (0, period). peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level (vertical shift) based formula 1 formula 2. sigma02 Variance estimate null (intercept ). sigmaA2 Variance estimate alternative (since curve fitting). l0 Log likelihood null (intercept ). l1 Log likelihood alternative (since curve fitting). stat Test statistic. pvalue P-value test. R2 Pseudo R2 defined (tss - rss)/tss.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"Caleb (Zhiguang Huo), Haocheng Ding","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/LR_rhythmicity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) LR_rhythmicity(tt, yy, period=24, method=\"LR\", FN=TRUE) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>"},{"path":"https://jcunow.github.io/RootScanR/reference/RPI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Root Penetration Index — RPI","title":"Calculate Root Penetration Index — RPI","text":"Calculate Root Penetration Index","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RPI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Root Penetration Index — RPI","text":"","code":"RPI(roots, w)"},{"path":"https://jcunow.github.io/RootScanR/reference/RPI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Root Penetration Index — RPI","text":"roots Numeric vector root coverage values w Numeric vector weights (typically depths)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RPI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Root Penetration Index — RPI","text":"Numeric RPI value -1 1","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RPI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Root Penetration Index — RPI","text":"","code":"w <- seq(5, 25, 5) roots <- c(0, 10, 7, 3, 1) rpi <- RPI(roots, w)"},{"path":"https://jcunow.github.io/RootScanR/reference/RWDI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Root Weight Depth Index — RWDI","title":"Calculate Root Weight Depth Index — RWDI","text":"Calculate Root Weight Depth Index","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RWDI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Root Weight Depth Index — RWDI","text":"","code":"RWDI(w, roots)"},{"path":"https://jcunow.github.io/RootScanR/reference/RWDI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Root Weight Depth Index — RWDI","text":"w Numeric vector weights (typically depths) roots Numeric vector root coverage values","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RWDI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Root Weight Depth Index — RWDI","text":"Numeric RWDI value","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/RWDI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Root Weight Depth Index — RWDI","text":"","code":"w <- seq(5, 25, 5) roots <- c(0, 10, 7, 3, 1) rwdi <- RWDI(w, roots)"},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Root Turnover Analysis Data — TurnoverDPC_data","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"Root turnover analysis sedge fen northern Finland, comparing root presence two time points (June 2023 October 2023) using RootDetector root tracking feature.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"","code":"data(TurnoverDPC_data)"},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"RasterBrick object dimensions: 2550 columns (width) 2273 rows (height) 3 layers (decay, growth, persistent)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"Multi-layer representation root dynamics : Layer 1: Root decay (value = 1) Roots disappeared time points Foreign objects (e.g., tape) Persistent roots Layer 2: Root growth (value = 1) New roots appeared Persistent roots Layer 3: Persistent roots (value = 1) Roots present time points Background represented 0 layers.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/TurnoverDPC_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root Turnover Analysis Data — TurnoverDPC_data","text":"","code":"if (FALSE) { # \\dontrun{   data(TurnoverDPC_data)   img = terra::rast(TurnoverDPC_data)   # Plot individual layers   terra::plot(img)   # Calculate turnover statistics   decay <- sum(terra::values(img[[1]]) == 1)   growth <- sum(terra::values(img[[2]]) == 1)   persistent <- sum(terra::values(img[[3]]) == 1) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"Test significance circadian curve fitting using finite sample Wald test","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"","code":"WaldTest(tt, yy, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"list , B, offset, df, stat, pvalue Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) based formula 2 B B based formula 2 amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level based formula 1 formula 2 df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"Caleb (Zhiguang Huo)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/WaldTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) WaldTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $peakTime #> [1] 23.46361 #>  #> $offset #> [1] 3.028329 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine multi-dimensional arrays — abind2","title":"Combine multi-dimensional arrays — abind2","text":"Combine multi-dimensional arrays.  generalization cbind rbind.  Takes sequence vectors, matrices, arrays produces single array higher dimension.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine multi-dimensional arrays — abind2","text":"","code":"abind2(   ...,   along = N,   rev.along = NULL,   new.names = NULL,   force.array = TRUE,   make.names = use.anon.names,   use.anon.names = FALSE,   use.first.dimnames = FALSE,   hier.names = FALSE,   use.dnns = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine multi-dimensional arrays — abind2","text":"... number vectors, matrices, arrays, data frames. dimensions arrays must match, except one dimension (specified along=).  arguments named, name used name dimension along arrays joined.  Vectors treated dim attribute length one. Alternatively, can one (one) list argument supplied, whose components objects bound together.  Names list components treated way argument names. along (optional) dimension along bind arrays. default last dimension, .e., maximum length dim attribute supplied arrays.  along= can take non-negative value minimum length dim attribute supplied arrays plus one.  along= fractional value, value less 1, value greater N (N maximum lengths dim attribute objects bound together), new dimension created result.  cases, dimensions arguments must identical. rev.along (optional) Alternate way specify dimension along bind arrays:  along = N + 1 - rev.along.  provided mainly allow easy specification along = N + 1 (supplying                                       rev.along=0).  along rev.along supplied, supplied value along ignored. new.names (optional) new.names list, first choice dimnames attribute result.  structure dimnames attribute.  names particular dimension NULL, names dimension constructed ways. new.names character vector, used dimension names way argument names used.  Zero length (\"\") names ignored. force.array (optional) FALSE, rbind cbind called possible, .e., arguments vectors, along 1, arguments vectors matrices data frames along 1 2.  rbind cbind used, preserve data.frame classes (class r/cbind preserve).  Otherwise, abind convert objects class array.  Thus, guarantee array object returned, supply argument force.array=TRUE.  Note use rbind cbind introduces subtle changes way default dimension names constructed:  see examples . make.names (optional) TRUE, last resort dimnames along dimension deparsed versions anonymous arguments.  can result cumbersome names arguments expressions. <p>default FALSE. use.anon.names (optional) use.anon.names deprecated synonym make.names. use.first.dimnames (optional) dimension names present one argument, dimension names result take first available (default take                     last available, behavior                     rbind cbind.) hier.names (optional) TRUE, dimension names concatenated dimension composed argument name dimension names objects bound.  single list argument supplied, names components serve argument names.  hier.names can also values \"\" \"\"; determine order argument name dimension name put together (TRUE effect \"\"). use.dnns (default FALSE) Use names dimensions, e.g., names(dimnames(x)) non-empty.  multiple possible sources names dimnames, value use.first.dimnames determines result.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine multi-dimensional arrays — abind2","text":"merged multidimensional arrays","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine multi-dimensional arrays — abind2","text":"dimensions supplied vectors arrays need identical, e.g., arguments can mixture vectors matrices.  abind coerces arguments addition one dimension order make consistent arguments along=.  extra dimension added place specified along=. default action abind concatenate last dimension, rather increase number dimensions. example, result calling abind vectors longer vector (see first example ).  differs action rbind cbind return matrix called vectors.  abind can made behave like cbind vectors specifying along=2, like rbind specifying along=0. dimnames returned object pieced together dimnames arguments, names arguments.  Names dimension searched following order: new.names, argument name, dimnames (names) attribute last argument, dimnames (names) attribute second last argument, etc.  (Supplying                                          argument use.first.dimnames=TRUE changes                                          cause abind use dimnames names                                          first argument first.  default behavior                                          rbind cbind: use dimnames                                          later arguments.)  names supplied along dimension (either argument names dimnames                 arguments), names constructed anonymous arguments unless use.anon.names=FALSE. sourced 'abind' package:  https://doi.org/10.32614/CRAN.package.abind MIT-license","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/abind2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine multi-dimensional arrays — abind2","text":"Tony Plate tplate@acm.org Richard Heiberger","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/analyze_soil_texture.html","id":null,"dir":"Reference","previous_headings":"","what":"Texture calculation — analyze_soil_texture","title":"Texture calculation — analyze_soil_texture","text":"Texture calculation","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/analyze_soil_texture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Texture calculation — analyze_soil_texture","text":"","code":"analyze_soil_texture(   img.color,   grays = 7,   window = c(9, 9),   metrics = c(\"variance\", \"second_moment\") )"},{"path":"https://jcunow.github.io/RootScanR/reference/analyze_soil_texture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Texture calculation — analyze_soil_texture","text":"img.color Three-band raster path image grays Number gray levels window Window size GLCM metrics Texture metrics calculate","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/analyze_soil_texture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Texture calculation — analyze_soil_texture","text":"Raster texture metrics","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/analyze_soil_texture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Texture calculation — analyze_soil_texture","text":"","code":"data(rgb_Oulanka2023_Session03_T067) img = raster::brick(rgb_Oulanka2023_Session03_T067) analyze_soil_texture(img, 7, c(9,9), metrics = \"second_moment\") #> class      : RasterLayer  #> dimensions : 1160, 4899, 5682840  (nrow, ncol, ncell) #> resolution : 0.0002041233, 0.000862069  (x, y) #> extent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> crs        : NA  #> source     : memory #> names      : glcm_second_moment  #> values     : 0.1111111, 1  (min, max) #>"},{"path":"https://jcunow.github.io/RootScanR/reference/binning.html","id":null,"dir":"Reference","previous_headings":"","what":"Bin continuous depth values into discrete intervals — binning","title":"Bin continuous depth values into discrete intervals — binning","text":"Bin continuous depth values discrete intervals","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/binning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bin continuous depth values into discrete intervals — binning","text":"","code":"binning(depthmap, nn, round.option = \"rounding\")"},{"path":"https://jcunow.github.io/RootScanR/reference/binning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bin continuous depth values into discrete intervals — binning","text":"depthmap SpatRaster/matrix/array - continuous depth values nn numeric - bin width round.option character - binning method: \"rounding\", \"ceiling\", \"floor\"","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/binning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bin continuous depth values into discrete intervals — binning","text":"SpatRaster - binned depth values","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/binning.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bin continuous depth values into discrete intervals — binning","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) mask = img[[1]] - img[[2]] mask[mask == 255] <- NA img = img depthmap = create_depthmap(img,mask,start.soil = 2.9, select.layer = 2 ) #> Processing row 100 of 4900 #> Processing row 200 of 4900 #> Processing row 300 of 4900 #> Processing row 400 of 4900 #> Processing row 500 of 4900 #> Processing row 600 of 4900 #> Processing row 700 of 4900 #> Processing row 800 of 4900 #> Processing row 900 of 4900 #> Processing row 1000 of 4900 #> Processing row 1100 of 4900 #> Processing row 1200 of 4900 #> Processing row 1300 of 4900 #> Processing row 1400 of 4900 #> Processing row 1500 of 4900 #> Processing row 1600 of 4900 #> Processing row 1700 of 4900 #> Processing row 1800 of 4900 #> Processing row 1900 of 4900 #> Processing row 2000 of 4900 #> Processing row 2100 of 4900 #> Processing row 2200 of 4900 #> Processing row 2300 of 4900 #> Processing row 2400 of 4900 #> Processing row 2500 of 4900 #> Processing row 2600 of 4900 #> Processing row 2700 of 4900 #> Processing row 2800 of 4900 #> Processing row 2900 of 4900 #> Processing row 3000 of 4900 #> Processing row 3100 of 4900 #> Processing row 3200 of 4900 #> Processing row 3300 of 4900 #> Processing row 3400 of 4900 #> Processing row 3500 of 4900 #> Processing row 3600 of 4900 #> Processing row 3700 of 4900 #> Processing row 3800 of 4900 #> Processing row 3900 of 4900 #> Processing row 4000 of 4900 #> Processing row 4100 of 4900 #> Processing row 4200 of 4900 #> Processing row 4300 of 4900 #> Processing row 4400 of 4900 #> Processing row 4500 of 4900 #> Processing row 4600 of 4900 #> Processing row 4700 of 4900 #> Processing row 4800 of 4900 #> Processing row 4900 of 4900 binned.map = binning(depthmap,nn = 5)"},{"path":"https://jcunow.github.io/RootScanR/reference/blur.correction.html","id":null,"dir":"Reference","previous_headings":"","what":"Threshold an image to binirize image — blur.correction","title":"Threshold an image to binirize image — blur.correction","text":"Threshold image binirize image","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/blur.correction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Threshold an image to binirize image — blur.correction","text":"","code":"blur.correction(img, threshold = 0.4, select.layer = 2, mask.layer = 1)"},{"path":"https://jcunow.github.io/RootScanR/reference/blur.correction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Threshold an image to binirize image — blur.correction","text":"img SpatRaster object threshold Numeric value 0 1 thresholding select.layer Integer specifying layer used capture blur mask.layer Integer specifying layer preserves mask sections","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/blur.correction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Threshold an image to binirize image — blur.correction","text":"SpatRaster object","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/blur.correction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Threshold an image to binirize image — blur.correction","text":"","code":"blurred.img = terra::rast(seg_Oulanka2023_Session03_T067) img = blur.correction(blurred.img, 0.3)"},{"path":"https://jcunow.github.io/RootScanR/reference/circular_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a circular mean to determine average Directionality — circular_mean","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"Calculate circular mean determine average Directionality","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/circular_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"","code":"circular_mean(angles, input_units = \"degrees\", output_units = \"degrees\")"},{"path":"https://jcunow.github.io/RootScanR/reference/circular_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"angles Numeric vector input angles input_units Character string specifying input units (\"radians\" \"degrees\") output_units Character string specifying output units (\"radians\" \"degrees\")","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/circular_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"Numeric value representing average angle","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/circular_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"","code":"circular_mean(angles = c(360,90,0), input_units = \"degrees\", output_units = \"degrees\") #> [1] 26.56505"},{"path":"https://jcunow.github.io/RootScanR/reference/combine_images.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine Two Warped Images — combine_images","title":"Combine Two Warped Images — combine_images","text":"Combines two warped images blending overlapping regions concatenating non-overlapping parts.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/combine_images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine Two Warped Images — combine_images","text":"","code":"combine_images(warped_prev, warped_curr, overlap_start, overlap_end)"},{"path":"https://jcunow.github.io/RootScanR/reference/combine_images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine Two Warped Images — combine_images","text":"warped_prev cimg object representing first warped image. warped_curr cimg object representing second warped image. overlap_start integer specifying starting column index overlap region. overlap_end integer specifying ending column index overlap region.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/combine_images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine Two Warped Images — combine_images","text":"cimg object representing blended combined image.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/count_pixels.html","id":null,"dir":"Reference","previous_headings":"","what":"counts all pixels in a segmented image — count_pixels","title":"counts all pixels in a segmented image — count_pixels","text":"counts pixels segmented image","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/count_pixels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"counts all pixels in a segmented image — count_pixels","text":"","code":"count_pixels(img)"},{"path":"https://jcunow.github.io/RootScanR/reference/count_pixels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"counts all pixels in a segmented image — count_pixels","text":"img one layer image","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/count_pixels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"counts all pixels in a segmented image — count_pixels","text":"numeric value","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/count_pixels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"counts all pixels in a segmented image — count_pixels","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067)[[2]] rootpixel  = count_pixels(img)"},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"function generates depth map minirhizotron images, accounting tube geometry insertion angle.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"","code":"create_depthmap(   img,   mask = NULL,   sinoid = TRUE,   tube.thicc = 7,   tilt = 45,   dpi = 300,   start.soil = 0,   center.offset = 0,   select.layer = 2 )"},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"img Input image (accepts terra SpatRaster, matrix, array, file path). multi-band images, specify band_index parameter mask Raster mask indicating foreign objects (1 = mask, 0 NA = keep) sinoid Logical; TRUE, accounts tube curvature depth calculation tube.thicc Numeric; diameter minirhizotron tube cm tilt Numeric; minirhizotron tube insertion angle degrees (typically 30-45) dpi Numeric; image resolution dots per inch start.soil Numeric; soil surface boundary cm (0 = surface) center.offset Numeric; rotational center offset (0 = centered, 1 = edge) select.layer Integer. Specifies layer use input multi-band image. Default `2`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"terra raster object containing depth map","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"Johannes Cunow, Robert Weigel","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_depthmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create_depthmap","text":"","code":"data(seg_Oulanka2023_Session01_T067) seg_Oulanka2023_Session01_T067 = terra::rast(seg_Oulanka2023_Session01_T067) img = seg_Oulanka2023_Session01_T067 mask = seg_Oulanka2023_Session01_T067[[1]] - seg_Oulanka2023_Session01_T067[[2]] mask[mask == 255] <- NA map = create_depthmap(img,mask,start.soil = 0.1,   sinoid = TRUE,   tube.thicc = 7,   tilt = 45,   dpi = 300,   center.offset = 0 ) #> Processing row 100 of 4900 #> Processing row 200 of 4900 #> Processing row 300 of 4900 #> Processing row 400 of 4900 #> Processing row 500 of 4900 #> Processing row 600 of 4900 #> Processing row 700 of 4900 #> Processing row 800 of 4900 #> Processing row 900 of 4900 #> Processing row 1000 of 4900 #> Processing row 1100 of 4900 #> Processing row 1200 of 4900 #> Processing row 1300 of 4900 #> Processing row 1400 of 4900 #> Processing row 1500 of 4900 #> Processing row 1600 of 4900 #> Processing row 1700 of 4900 #> Processing row 1800 of 4900 #> Processing row 1900 of 4900 #> Processing row 2000 of 4900 #> Processing row 2100 of 4900 #> Processing row 2200 of 4900 #> Processing row 2300 of 4900 #> Processing row 2400 of 4900 #> Processing row 2500 of 4900 #> Processing row 2600 of 4900 #> Processing row 2700 of 4900 #> Processing row 2800 of 4900 #> Processing row 2900 of 4900 #> Processing row 3000 of 4900 #> Processing row 3100 of 4900 #> Processing row 3200 of 4900 #> Processing row 3300 of 4900 #> Processing row 3400 of 4900 #> Processing row 3500 of 4900 #> Processing row 3600 of 4900 #> Processing row 3700 of 4900 #> Processing row 3800 of 4900 #> Processing row 3900 of 4900 #> Processing row 4000 of 4900 #> Processing row 4100 of 4900 #> Processing row 4200 of 4900 #> Processing row 4300 of 4900 #> Processing row 4400 of 4900 #> Processing row 4500 of 4900 #> Processing row 4600 of 4900 #> Processing row 4700 of 4900 #> Processing row 4800 of 4900 #> Processing row 4900 of 4900"},{"path":"https://jcunow.github.io/RootScanR/reference/create_root_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a buffer halo) around non-zero pixels — create_root_buffer","title":"Create a buffer halo) around non-zero pixels — create_root_buffer","text":"Create buffer halo) around non-zero pixels","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_root_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a buffer halo) around non-zero pixels — create_root_buffer","text":"","code":"create_root_buffer(img, width = 2, halo.only = TRUE, kernel = \"circle\")"},{"path":"https://jcunow.github.io/RootScanR/reference/create_root_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a buffer halo) around non-zero pixels — create_root_buffer","text":"img SpatRaster/matrix/array - segmented image width numeric - buffer width pixels (default: 2) halo.logical - TRUE, returns buffer zone (default: TRUE) kernel character - shape thickening kernel: \"circle\" \"diamond\"","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_root_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a buffer halo) around non-zero pixels — create_root_buffer","text":"SpatRast - buffer zone around non-zero pixels","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/create_root_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a buffer halo) around non-zero pixels — create_root_buffer","text":"","code":"data(seg_Oulanka2023_Session03_T067) img <- terra::rast(seg_Oulanka2023_Session03_T067) create_root_buffer(img, width = 2) #> class       : SpatRaster  #> dimensions  : 1161, 4900, 3  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 4900, 0, 1161  (xmin, xmax, ymin, ymax) #> coord. ref. :   #> source(s)   : memory #> names       : lyr.1, lyr.2, lyr.3  #> min values  :  -254,  -254,  -254  #> max values  :     1,     1,     1"},{"path":"https://jcunow.github.io/RootScanR/reference/deep_drive.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Deep Drive Estimate for Root Systems — deep_drive","title":"Calculate Deep Drive Estimate for Root Systems — deep_drive","text":"function analyzes root growth directions relation depth gradients. calculates ratio root pixels growing direction steepest depth slope compared root pixels.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/deep_drive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Deep Drive Estimate for Root Systems — deep_drive","text":"","code":"deep_drive(   DepthMap = NULL,   AngleMap = NULL,   RootMap = NULL,   select.layerRM = NULL,   select.layerDM = NULL,   select.layerAM = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/deep_drive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Deep Drive Estimate for Root Systems — deep_drive","text":"DepthMap SpatRast object containing depth information AngleMap Optional SpatRast D8 root angles (terra::terrain(v=\"flowdir\")) RootMap Optional SpatRast containing segmented, presence-absence root image select.layerRM Integer. Specifies layer use input multi-band image. Default `2`. select.layerDM Integer. Specifies layer use input multi-band image. Default `NULL`. select.layerAM Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/deep_drive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Deep Drive Estimate for Root Systems — deep_drive","text":"return_diagnostics=FALSE, returns numeric value representing ratio aligned root pixels         total root pixels. TRUE, returns list containing ratio diagnostic information.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/deep_drive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Deep Drive Estimate for Root Systems — deep_drive","text":"","code":"data(skl_Oulanka2023_Session01_T067) im = ceiling(terra::rast(skl_Oulanka2023_Session01_T067)/255) DepthMap = terra::t(create_depthmap(im,center.offset=0,tube.thicc=3.5)) #> Processing row 100 of 4900 #> Processing row 200 of 4900 #> Processing row 300 of 4900 #> Processing row 400 of 4900 #> Processing row 500 of 4900 #> Processing row 600 of 4900 #> Processing row 700 of 4900 #> Processing row 800 of 4900 #> Processing row 900 of 4900 #> Processing row 1000 of 4900 #> Processing row 1100 of 4900 #> Processing row 1200 of 4900 #> Processing row 1300 of 4900 #> Processing row 1400 of 4900 #> Processing row 1500 of 4900 #> Processing row 1600 of 4900 #> Processing row 1700 of 4900 #> Processing row 1800 of 4900 #> Processing row 1900 of 4900 #> Processing row 2000 of 4900 #> Processing row 2100 of 4900 #> Processing row 2200 of 4900 #> Processing row 2300 of 4900 #> Processing row 2400 of 4900 #> Processing row 2500 of 4900 #> Processing row 2600 of 4900 #> Processing row 2700 of 4900 #> Processing row 2800 of 4900 #> Processing row 2900 of 4900 #> Processing row 3000 of 4900 #> Processing row 3100 of 4900 #> Processing row 3200 of 4900 #> Processing row 3300 of 4900 #> Processing row 3400 of 4900 #> Processing row 3500 of 4900 #> Processing row 3600 of 4900 #> Processing row 3700 of 4900 #> Processing row 3800 of 4900 #> Processing row 3900 of 4900 #> Processing row 4000 of 4900 #> Processing row 4100 of 4900 #> Processing row 4200 of 4900 #> Processing row 4300 of 4900 #> Processing row 4400 of 4900 #> Processing row 4500 of 4900 #> Processing row 4600 of 4900 #> Processing row 4700 of 4900 #> Processing row 4800 of 4900 #> Processing row 4900 of 4900  deep_drive(DepthMap = DepthMap, RootMap = im, select.layerRM = 2, select.layerAM = 2) #> Warning: Warning in main function: No valid pixels found for calculation"},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"Identifies branching points endpoints skeletonized binary image.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"","code":"detect_skeleton_points(img, select.layer = 2)"},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"img matrix, data frame, `SpatRaster` object representing skeletonized binary image. select.layer Integer. Specifies layer use input multi-band image. Default `2`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"named list containing two `SpatRaster` objects: endpoints: binary raster endpoints marked 1. branching_points: binary raster branching points marked 1.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"function detects key points skeletonized binary image: Endpoints: Pixels exactly one neighbor skeleton. Branching Points: Pixels two neighbors skeleton. function uses 3x3 neighborhood kernel count number neighbors foreground pixel (1) image. Based neighbor count, points classified endpoints branching points. input image skeletonized (thin connected) using function. already binary, input image binarized internally.","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/reference/detect_skeleton_points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Skeleton Points: Branching Points and Endpoints — detect_skeleton_points","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  # Example skeletonized image skeleton <- rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0), nrow = 4))  # Detect endpoints and branching points points <- detect_skeleton_points(skeleton)  # Access results endpoints <- points$endpoints branching_points <- points$branching_points } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_center.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimates rotation from tape coverage — estimate_rotation_center","title":"Estimates rotation from tape coverage — estimate_rotation_center","text":"function analyzes image data determine rotation based tape coverage, assuming tape present upper side tube.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_center.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimates rotation from tape coverage — estimate_rotation_center","text":"","code":"estimate_rotation_center(   img,   tape.brightness = 0.66,   extra.rows = 100,   search.area = 0.45,   tape.quantile = 0.98,   nclasses = 3,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_center.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimates rotation from tape coverage — estimate_rotation_center","text":"img Input image raster, file name, array tape.brightness Brightness threshold tape detection (0-1) extra.rows Additional rows add analysis search.area Proportion image analyze (0-1) tape.quantile Quantile used align brightness tape (0-1) nclasses Number classes pixel clustering select.layer Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_center.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimates rotation from tape coverage — estimate_rotation_center","text":"numeric Position center extruding tape","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_center.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimates rotation from tape coverage — estimate_rotation_center","text":"","code":"img = seg_Oulanka2023_Session01_T067 r0 = estimate_rotation_center(img)"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect rotation shift between two images — estimate_rotation_shift","title":"Detect rotation shift between two images — estimate_rotation_shift","text":"Calculates rotation shift two sequential images using either cross-correlation phase correlation methods.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect rotation shift between two images — estimate_rotation_shift","text":"","code":"estimate_rotation_shift(   img1,   img2,   cor.type = \"phase\",   fixed.depth.pixel = c(1000, 4000),   fixed.width = NULL,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect rotation shift between two images — estimate_rotation_shift","text":"img1 Reference image (3-channel RGB) img2 Subsequent image compare (3-channel RGB) cor.type Correlation type: \"ccf\" (cross) \"phase\" (frequency domain) fixed.depth.pixel Depth range analyze c(start, end) fixed.width Width analysis region pixels select.layer Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect rotation shift between two images — estimate_rotation_shift","text":"Vector shifts (x,y) pixels","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_rotation_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect rotation shift between two images — estimate_rotation_shift","text":"","code":"img1 = seg_Oulanka2023_Session01_T067 img2 = seg_Oulanka2023_Session03_T067 y.lag = estimate_rotation_shift(img1,img2,\"phase\") #> Warning: Warning in RotShiftDet: Images differ in size by -17 x 0 pixels"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_soil_surface.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate soil surface position using tape markers — estimate_soil_surface","title":"Estimate soil surface position using tape markers — estimate_soil_surface","text":"Detects soil surface analyzing tape coverage patterns image.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_soil_surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate soil surface position using tape markers — estimate_soil_surface","text":"","code":"estimate_soil_surface(   img,   search.area = 0.45,   tape.tresh = 0.33,   dpi = 150,   nclasses = 3,   inverse = FALSE,   tape.overlap = 0.5,   tape.brightness = 0.6,   extra.rows = 100,   tape.quantile = 0.98,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_soil_surface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate soil surface position using tape markers — estimate_soil_surface","text":"img Input image (raster, filename, array) search.area Proportion image analyze tape.tresh Minimum tape coverage ratio dpi Image resolution nclasses Number clustering classes inverse Invert detection dark markers tape.overlap Safety margin tape (cm) tape.brightness Brightness threshold tape extra.rows Additional analysis rows tape.quantile Brightness alignment quantile select.layer Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_soil_surface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate soil surface position using tape markers — estimate_soil_surface","text":"data.frame soil surface tape end positions","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_soil_surface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate soil surface position using tape markers — estimate_soil_surface","text":"","code":"img = rgb_Oulanka2023_Session03_T067 Soil0Estimates = estimate_soil_surface(img)"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_translation.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Translation Between Overlap Regions — estimate_translation","title":"Estimate Translation Between Overlap Regions — estimate_translation","text":"Computes translation required align two overlapping regions using either cross-correlation phase-correlation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_translation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Translation Between Overlap Regions — estimate_translation","text":"","code":"estimate_translation(prev_region, curr_region, method = \"crosscorr\")"},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_translation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Translation Between Overlap Regions — estimate_translation","text":"prev_region cimg object representing overlap region previous image. curr_region cimg object representing overlap region current image. method string specifying method estimating translation. One \"crosscorr\" \"phasecorr\". Default \"crosscorr\".","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/estimate_translation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Translation Between Overlap Regions — estimate_translation","text":"numeric vector length two containing translation offsets (dx, dy).","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/extract_overlap_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Overlap Region from an Image — extract_overlap_region","title":"Extract Overlap Region from an Image — extract_overlap_region","text":"Extracts region image corresponding specified overlap along given side.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/extract_overlap_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Overlap Region from an Image — extract_overlap_region","text":"","code":"extract_overlap_region(img, overlap_px = 250, side)"},{"path":"https://jcunow.github.io/RootScanR/reference/extract_overlap_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Overlap Region from an Image — extract_overlap_region","text":"img cimg object representing image. overlap_px integer specifying size overlap region pixels. Default 200. side string specifying side image extract overlap . One \"top\", \"bottom\", \"left\", \"right\".","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/extract_overlap_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Overlap Region from an Image — extract_overlap_region","text":"cimg object representing extracted overlap region.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher information matrix when two conditions exist — fisherInformation2","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Obtain Fisher information matrix two conditions exist","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"","code":"fisherInformation2(beta, tt1, yy1, tt2, yy2, period = 24)"},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"beta parameter vector 8 following order: amp_1, phase_1, offset_1, theta_1, amp_2, phase_2, offset_2, theta_2 tt1 time vector condition 1 yy1 expression vector condition 1 tt2 time vector condition 2 yy2 expression vector condition 2 period Period since curve. Default 24.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Fisher information matrix, 8*8 matrix, order input beta parameter.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Caleb (Zhiguang Huo)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fisherInformation2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 15 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) beta <- c(Amp1,Phase1,Offset1,1,Amp2,Phase2,Offset2,2) fisherInformation2(beta, tt1, yy1, tt2, yy2) #>         [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,] 25.4561    0    0    0    0    0    0    0 #> [2,]  0.0000    0    0    0    0    0    0    0 #> [3,]  0.0000    0    0    0    0    0    0    0 #> [4,]  0.0000    0    0    0    0    0    0    0 #> [5,]  0.0000    0    0    0    0    0    0    0 #> [6,]  0.0000    0    0    0    0    0    0    0 #> [7,]  0.0000    0    0    0    0    0    0    0 #> [8,]  0.0000    0    0    0    0    0    0    0"},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Data Based on Sine Curve — fitSinCurve","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"Fit sine curve tt time, yy expression value.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"","code":"fitSinCurve(   tt,   yy,   period = 24,   parStart = list(amp = 3, phase = 0, offset = 0) )"},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"tt Time vector. yy Expression vector. period Period sine curve. Default 24. parStart Initial value optimization purpose.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"list amp, phase, offset, peak, , B, SST, SSE, R2. Formula 1: \\(yy = amp * sin(2\\pi/period * (phase + tt)) + offset\\) Formula 2: \\(yy = * sin(2\\pi/period \\times tt) + B * cos(2*\\pi/period * tt) + offset\\) amp Amplitude based formula 1. phase Phase based formula 1, phase restricted within (0, period). offset Basal level (vertical shift) based formula 1 formula 2. based formula 2. B B based formula 2. tss Total sum square. rss Residual sum square, SSE/n MLE variance sigma square. R2 Pseudo R2 defined (tss - rss)/tss.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"sourced : https://rdrr.io/github/diffCircadian/diffCircadian/ GPL3 license author: Zhiguang Huo, Haocheng Ding Feb. 24, 2023, 9:07 .m.; Version 0.0.0 journal article: https://doi.org/10.1093/bib/bbab224 tutorial (circadian data): http://htmlpreview.github.io/?https://github.com/diffCircadian/diffCircadian/blob/master/vignettes/diffCircadian_tutorial.html","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"Caleb (Zhiguang Huo)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/fitSinCurve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) fitSinCurve(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $offset #> [1] 3.028329 #>  #> $peak #> [1] -0.5363939 #>  #> $A #> [1] -0.268095 #>  #> $B #> [1] 1.896567 #>  #> $tss #> [1] 125.0438 #>  #> $rss #> [1] 27.31912 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/RootScanR/reference/image_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Threshold an image to binarize image — image_threshold","title":"Threshold an image to binarize image — image_threshold","text":"Threshold image binarize image","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/image_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Threshold an image to binarize image — image_threshold","text":"","code":"image_threshold(   img,   threshold = 0.4,   method = \"global\",   window_size = 15,   select.layer = 2,   mask.layer = 1,   binary_01 = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/image_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Threshold an image to binarize image — image_threshold","text":"img SpatRaster object threshold Numeric value 0 1 representing fraction reference value. global thresholding, fraction global maximum. adaptive thresholding, fraction local mean. method Character string specifying thresholding method: \"global\" \"adaptive\" window_size Integer specifying window size adaptive thresholding (must odd) select.layer Integer NULL specifying layer used thresholding. NULL, average layers used. mask.layer Integer NULL specifying layer preserves mask sections. NULL, mask applied. binary_01 Logical; TRUE, output values strictly 0 1. FALSE, uses maximum value input.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/image_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Threshold an image to binarize image — image_threshold","text":"SpatRaster object","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/image_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Threshold an image to binarize image — image_threshold","text":"","code":"img = terra::rast(seg_Oulanka2023_Session03_T067) # Global thresholding (threshold = 0.3 means pixels > 30% of global max value become 1) binary_img1 = image_threshold(img, threshold = 0.3, method = \"global\") # Adaptive thresholding (threshold = 0.9 means pixels > 90% of local mean become 1) binary_img2 = image_threshold(img,                  threshold = 0.9, method = \"adaptive\",                  window_size = 15, binary_01 = TRUE) # Using average of all layers with no mask binary_img3 = image_threshold(img, select.layer = NULL, mask.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/load_flexible_image.html","id":null,"dir":"Reference","previous_headings":"","what":"Load an image flexibly from file or convert from memory — load_flexible_image","title":"Load an image flexibly from file or convert from memory — load_flexible_image","text":"Load image flexibly file convert memory","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/load_flexible_image.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load an image flexibly from file or convert from memory — load_flexible_image","text":"","code":"load_flexible_image(   input,   output_format = \"cimg\",   normalize = TRUE,   select.layer = NULL,   binarize = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/load_flexible_image.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load an image flexibly from file or convert from memory — load_flexible_image","text":"input File path image object output_format Character, one \"cimg\", \"spatrast\", \"array\", \"brick\", \"raster\" normalize Logical, whether normalize values 0-1 range 0-255 select.layer Numeric, layer select input multiple layers binarize Logical, whether output strictly 0 1. Overwrites normalize","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Medial Axis Transform (Internal) — medial_axis_transform","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"internal function computes medial axis transform binary image, identifying set skeleton points equidistant object's boundaries.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"","code":"medial_axis_transform(img, verbose = FALSE, select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"img matrix, data frame, `SpatRaster` object representing binary image transformation. verbose Logical. `TRUE`, outputs diagnostic information image dimensions, progress computation, final skeleton size. Default `FALSE`. select.layer Integer indicating layer use `img` multi-layer `SpatRaster`. Default 2.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"binary matrix `1` represents skeleton pixels `0` represents background.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"- input image first processed using load_flexible_image ensure binary matrix. - algorithm proceeds following steps:   1. **Distance Transform**: Computes distance foreground pixel nearest background pixel using two-pass algorithm.   2. **Local Maxima Detection**: Identifies local maxima distance transform mark potential skeleton points.   3. **Skeleton Refinement**: Ensures connectivity connecting skeleton points within 8-neighborhood. - result binary image representing medial axis input object.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/medial_axis_transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Medial Axis Transform (Internal) — medial_axis_transform","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage raster <- terra::rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0,1), nrow = 3)) skeleton <- medial_axis_transform(raster, verbose = TRUE) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/modal_peaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Modal Peaks in a Density Estimation — modal_peaks","title":"Find Modal Peaks in a Density Estimation — modal_peaks","text":"function identifies peaks valleys density estimation input data. computes prominence peak allows user filter peaks based prominence threshold. function also provides option visualize data either density plot, raw line plot, display.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/modal_peaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Modal Peaks in a Density Estimation — modal_peaks","text":"","code":"modal_peaks(x, prominence_threshold = 0.005, display_type = \"density\")"},{"path":"https://jcunow.github.io/RootScanR/reference/modal_peaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Modal Peaks in a Density Estimation — modal_peaks","text":"x numeric vector data modal peaks identified. prominence_threshold numeric value specifying minimum prominence peaks considered. `NULL`, prominence threshold applied. Default 0.005. display_type character string indicating type output display. Options : - `\"density\"` density plot peaks valleys marked (default), - `\"raw\"` raw line plot peaks valleys marked, - `\"none\"` plot, just returning peak valley data.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/modal_peaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Modal Peaks in a Density Estimation — modal_peaks","text":"list containing:         - `peak_x`: x-coordinates detected peaks.         - `peak_y`: y-coordinates (density values) detected peaks.         - `valley_x`: x-coordinates detected valleys (NULL none).         - `valley_y`: y-coordinates (density values) detected valleys (NULL none).         - `prominences`: prominence peak (NULL none).         - message indicating number modes distribution.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/modal_peaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Modal Peaks in a Density Estimation — modal_peaks","text":"","code":"# Simulate a bimodal distribution set.seed(123) x <- c(rnorm(500, mean = -2, sd = 1), rnorm(500, mean = 3, sd = 1))  # Call the function with density plot (default) results_density <- modal_peaks(x, prominence_threshold = 0.005, display_type = \"density\") #> The distribution is bimodal (2 peaks detected).   # Call the function with raw line plot results_raw <- modal_peaks(x, prominence_threshold = 0.005, display_type = \"raw\") #> The distribution is bimodal (2 peaks detected).   # Call the function with no display (just returns results) results_none <- modal_peaks(x, prominence_threshold = 0.005, display_type = \"none\") #> The distribution is bimodal (2 peaks detected)."},{"path":"https://jcunow.github.io/RootScanR/reference/normalize_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize or binarize the array or raster — normalize_array","title":"Normalize or binarize the array or raster — normalize_array","text":"Normalize binarize array raster","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/normalize_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize or binarize the array or raster — normalize_array","text":"","code":"normalize_array(arr, normalize, binarize)"},{"path":"https://jcunow.github.io/RootScanR/reference/rgb2gray.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert RGB image to grayscale with optimized memory management and parallel processing — rgb2gray","title":"Convert RGB image to grayscale with optimized memory management and parallel processing — rgb2gray","text":"Convert RGB image grayscale optimized memory management parallel processing","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb2gray.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert RGB image to grayscale with optimized memory management and parallel processing — rgb2gray","text":"","code":"rgb2gray(img, r = 0.21, g = 0.72, b = 0.07)"},{"path":"https://jcunow.github.io/RootScanR/reference/rgb2gray.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert RGB image to grayscale with optimized memory management and parallel processing — rgb2gray","text":"img SpatRaster RGB image r Weight red channel g Weight green channel b Weight blue channel","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb2gray.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert RGB image to grayscale with optimized memory management and parallel processing — rgb2gray","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = seg_Oulanka2023_Session01_T067 gray.raster = rgb2gray(img)"},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"Original RGB root scan image sedge fen northern Finland (October 2023). image represents composite multiple stitched scans.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"","code":"data(rgb_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"RasterBrick object dimensions: 4900 columns (width) 1161 rows (height) 3 layers (RGB channels)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"image represents complete tube scan : Columns correspond tube length Rows correspond tube rotation RGB channels represent true color information","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rgb_Oulanka2023_Session03_T067.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Original Minirhizotron Root Scan - Session 3, Tube 67 — rgb_Oulanka2023_Session03_T067","text":"","code":"if (FALSE) { # \\dontrun{   data(rgb_Oulanka2023_Session03_T067)   rgb_Oulanka2023_Session03_T067 = terra::rast(rgb_Oulanka2023_Session03_T067)   terra::plotRGB(rgb_Oulanka2023_Session03_T067) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/root_accumulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate root accumulation — root_accumulation","title":"Calculate root accumulation — root_accumulation","text":"Calculate root accumulation","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_accumulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate root accumulation — root_accumulation","text":"","code":"root_accumulation(x, group, depth, variable, stdrz = \"counts\")"},{"path":"https://jcunow.github.io/RootScanR/reference/root_accumulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate root accumulation — root_accumulation","text":"x Data frame containing group, depth, variable columns group Character vector specifying grouping variable(s) depth Character string specifying depth column name variable Character string specifying accumulating values column stdrz Character string specifying standardization method","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_accumulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate root accumulation — root_accumulation","text":"Numeric vector accumulated values","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_accumulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate root accumulation — root_accumulation","text":"","code":"df = data.frame(depth = c(seq(0,80,20),seq(0,80,20)),                Plot = c(rep(\"a\",5),rep(\"b\",5)), rootpx = c(5,50,20,15,5,10,40,30,10,5) ) accum_root = root_accumulation(df,group = \"Plot\", depth = \"depth\", variable = \"rootpx\")"},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Root Diameters — root_diameter","title":"Estimate Root Diameters — root_diameter","text":"function estimates root diameters input image using skeletonization distance transform methods. input can file path, raster, image object, array, converted binary image processing.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Root Diameters — root_diameter","text":"","code":"root_diameter(   img,   diagnostics = FALSE,   skeleton_method = \"GuoHall\",   select.layer = 2 )"},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Root Diameters — root_diameter","text":"img character string (file path), `SpatRaster`, `RasterBrick`, `RasterLayer`, `cimg`, `magick-image`, array. input image process. diagnostics Logical. `TRUE`, enables diagnostic plots logging. Default `FALSE`. skeleton_method Character. method use skeletonization. Default `\"Guo-Hall\"`. select.layer Integer. Specifies layer use input multi-band image. Default `2`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Root Diameters — root_diameter","text":"list containing: quantiles Numeric vector diameter quantiles (10th 100th percentile). mean_diameter Numeric. mean root diameter. median_diameter Numeric. median root diameter. diameters Numeric vector diameter values skeletonized regions. skeleton_rast `SpatRaster`. Binary raster mask skeletonized regions. diameter_rast `SpatRaster`. Raster showing diameters skeletonized regions. distance_map_rast `SpatRaster`. Raster showing distance transform values.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Root Diameters — root_diameter","text":"function works follows: - Converts input image binary format (`cimg`). - Applies distance transform compute Euclidean distance foreground (root) pixels. - Skeletonizes binary image identify root centerlines. - Filters distance values retain corresponding skeletonized regions. - Computes diameter statistics, including quantiles, mean, median diameters. function supports various input formats normalizes image values range [0, 1] needed. uses `terra` package raster operations `imager` package image processing.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_diameter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Root Diameters — root_diameter","text":"","code":"# Example usage: data(seg_Oulanka2023_Session01_T067) result <- root_diameter( img = seg_Oulanka2023_Session01_T067, skeleton_method = \"GuoHall\", select.layer = 2, diagnostics = TRUE) #>  #> Applying method: GuoHall  #> Image dimensions: 1144 x 4900  #> Initial foreground pixels: 200781  #> Processing complete. Summary statistics: #> Mean diameter: 2.14 #> Median diameter: 2.00 #> Number of valid measurements: 7624  # Access results: print(result$mean_diameter) #> [1] 2.142038 terra::plot(result$skeleton_rast)"},{"path":"https://jcunow.github.io/RootScanR/reference/root_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Root Length using Kimura's Method with optimizations — root_length","title":"Calculate Root Length using Kimura's Method with optimizations — root_length","text":"Calculate Root Length using Kimura's Method optimizations","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Root Length using Kimura's Method with optimizations — root_length","text":"","code":"root_length(img, unit = \"cm\", dpi = 300, select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/root_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Root Length using Kimura's Method with optimizations — root_length","text":"img skeletonized root image raster unit Output unit (\"px\" \"cm\") dpi Image resolution (required unit = \"cm\") select.layer Integer. Specifies layer use input multi-band image. Default `2`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Root Length using Kimura's Method with optimizations — root_length","text":"Numeric value representing root length specified unit","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Root Length using Kimura's Method with optimizations — root_length","text":"","code":"data(skl_Oulanka2023_Session01_T067) img = terra::rast(skl_Oulanka2023_Session01_T067) RL = root_length(img = img,unit = \"cm\", dpi = 300, select.layer = 2)"},{"path":"https://jcunow.github.io/RootScanR/reference/root_scape_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","text":"RootScapeMetric relies Landscapemetrics extract 'Root Scape' Features akin landscape analysis.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_scape_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","text":"","code":"root_scape_metrics(   img,   indexD = NA,   select.layer = NULL,   metrics = c(\"lsm_c_ca\", \"lsm_l_ent\", \"lsm_c_pd\", \"lsm_c_np\", \"lsm_c_pland\",     \"lsm_c_area_mn\", \"lsm_c_area_cv\", \"lsm_c_enn_mn\", \"lsm_c_enn_cv\") )"},{"path":"https://jcunow.github.io/RootScanR/reference/root_scape_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","text":"img segmented raster  (values = 0,1). Consider whether skeletonized raster appropriate. indexD please specify depth. affect output column = \"depth\". Useful used loop. select.layer Integer. Specifies layer use input multi-band image. Default `2`. metrics ,metrics calculated available ones 'landscapemetrics::calculate_lsm()'.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_scape_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","text":"bunch metric values","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_scape_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — root_scape_metrics","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) RootScapeObject  = root_scape_metrics(img,indexD = 80, select.layer = 2,  metrics = c(\"lsm_c_ca\")) #> Warning: Please use 'check_landscape()' to ensure the input data is valid."},{"path":"https://jcunow.github.io/RootScanR/reference/root_thickness.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate average Root Thickness — root_thickness","title":"Approximate average Root Thickness — root_thickness","text":"Approximate average Root Thickness","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_thickness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate average Root Thickness — root_thickness","text":"","code":"root_thickness(kimuralength, rootpx, dpi = 300)"},{"path":"https://jcunow.github.io/RootScanR/reference/root_thickness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate average Root Thickness — root_thickness","text":"kimuralength length roots image section, input unit cm. rootpx amount rootpx image section dpi image resolution","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_thickness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate average Root Thickness — root_thickness","text":"value units cm","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_thickness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate average Root Thickness — root_thickness","text":"","code":"root.ticc = root_thickness(kimuralength = 300,rootpx = 9500, dpi = 300)"},{"path":"https://jcunow.github.io/RootScanR/reference/root_turnover.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Root Turnover Analysis — root_turnover","title":"Unified Root Turnover Analysis — root_turnover","text":"Performs root turnover analysis either single multi-layer image two separate images","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_turnover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Root Turnover Analysis — root_turnover","text":"","code":"root_turnover(   img1,   img2 = NULL,   method = \"kimura\",   unit = \"cm\",   dpi = 300,   select.layer = NULL,   product.layer = 2,   decay.layer = 1,   blur.capture = 0.95,   im.return = FALSE,   include.virtualroots = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/root_turnover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Root Turnover Analysis — root_turnover","text":"img1 Primary SpatRaster input (either multi-layer first timepoint image) img2 Optional second timepoint image (img1 single timepoint) method Analysis method: \"kimura\", \"rootpx\", \"dpc\" (root decomposition) unit Unit root length measurement (method = \"kimura\"). Default: \"cm\" dpi Image resolution (method = \"kimura\"). Default: 300 select.layer Integer NULL. two images provided multiple layers, specifies layer use. img1 multi-layer, ignored DPC method. product.layer Integer indicating production layer index DPC method (1-3) decay.layer Integer indicating decay & tape layer index DPC method (1-3) blur.capture Threshold pixel inclusion DPC method (0-1). Default: 0.95 im.return Logical: return images instead values DPC method? Default: FALSE include.virtualroots Logical: consider roots present timepoint DPC method? Default: FALSE","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/root_turnover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Root Turnover Analysis — root_turnover","text":"Depends method parameters:   - temporal comparison: data.frame root production turnover   - DPC method: tibble pixel sums ratios list SpatRaster layers","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rotation_censor.html","id":null,"dir":"Reference","previous_headings":"","what":"Censor image edges based on rotation — rotation_censor","title":"Censor image edges based on rotation — rotation_censor","text":"Crops image edges handle non-overlapping regions sequential scans.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rotation_censor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Censor image edges based on rotation — rotation_censor","text":"","code":"rotation_censor(   img,   center.offset = 0,   cut.buffer = 0.02,   fixed.rotation = TRUE,   fixed.width = 500,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/rotation_censor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Censor image edges based on rotation — rotation_censor","text":"img Input image censor center.offset Rotation shift rows (RotShiftDet) cut.buffer Proportion image cut fixed_rotation=FALSE fixed.rotation Use fixed output dimensions fixed.width Output width fixed_rotation=TRUE select.layer Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rotation_censor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Censor image edges based on rotation — rotation_censor","text":"Cropped raster image","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/rotation_censor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Censor image edges based on rotation — rotation_censor","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) censored.raster = rotation_censor(img,center.offset = 120, cut.buffer = 0.02, fixed.rotation = FALSE)"},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"Segmented root scan image sedge fen northern Finland (June 2023). image processed using RootDetector root segmentation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"","code":"data(seg_Oulanka2023_Session01_T067)"},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"RasterBrick object dimensions: 4900 columns (width) 1144 rows (height) 3 layers (channels)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"Binary mask representation : Roots = 1 Background = 0 Layer 1 includes foreign objects (e.g., tape) marked 1 Spatial dimensions correspond physical tube measurements: columns = tube length, rows = tube rotation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session01_T067.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Segmented Minirhizotron Root Scan - Session 1, Tube 67 — seg_Oulanka2023_Session01_T067","text":"","code":"if (FALSE) { # \\dontrun{   data(seg_Oulanka2023_Session01_T067)   seg_Oulanka2023_Session01_T067 = terra::rast(seg_Oulanka2023_Session01_T067)   terra::plot(seg_Oulanka2023_Session01_T067) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"Segmented root scan image sedge fen northern Finland (October 2023). image processed using RootDetector root segmentation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"","code":"data(seg_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"RasterBrick object dimensions: 4900 columns (width) 1161 rows (height) 3 layers (channels)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"Binary mask representation : Roots = 1 Background = 0 Layer 1 includes foreign objects (e.g., tape) marked 1 Spatial dimensions correspond physical tube measurements: columns = tube length, rows = tube rotation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/seg_Oulanka2023_Session03_T067.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Segmented Minirhizotron Root Scan - Session 3, Tube 67 — seg_Oulanka2023_Session03_T067","text":"","code":"if (FALSE) { # \\dontrun{   data(seg_Oulanka2023_Session03_T067)   seg_Oulanka2023_Session03_T067 = terra::rast(seg_Oulanka2023_Session03_T067)   terra::plot(seg_Oulanka2023_Session03_T067) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":null,"dir":"Reference","previous_headings":"","what":"Skeletonization Wrapper Function — skeletonize_image","title":"Skeletonization Wrapper Function — skeletonize_image","text":"function serves wrapper applying different skeletonization methods binary image, including Zhang-Suen, Guo-Hall, Medial Axis Transform (MAT) algorithms.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skeletonization Wrapper Function — skeletonize_image","text":"","code":"skeletonize_image(   img,   methods = c(\"ZhangSuen\", \"GuoHall\", \"MAT\"),   verbose = TRUE,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Skeletonization Wrapper Function — skeletonize_image","text":"img matrix, data frame, `SpatRaster` object representing binary image skeletonized. methods character vector specifying skeletonization methods apply. Valid options \"ZhangSuen\", \"GuoHall\", \"MAT\". Defaults three methods. verbose Logical. TRUE, displays progress diagnostic messages processing. Defaults TRUE. select.layer Integer specifying layer use img multi-layer `SpatRaster`. Defaults 2.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Skeletonization Wrapper Function — skeletonize_image","text":"single method selected, function returns `SpatRaster` object representing skeletonized image. multiple methods selected, named list `SpatRaster` objects returned.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skeletonization Wrapper Function — skeletonize_image","text":"function allows flexible streamlined skeletonization binary images using one supported algorithms: \"ZhangSuen\": Implements Zhang-Suen thinning algorithm. \"GuoHall\": Implements Guo-Hall thinning algorithm. \"MAT\": Computes Medial Axis Transform extract skeleton. function processes input image specified methods returns results. multiple methods chosen, results returned named list, element corresponding method.","code":""},{"path":[]},{"path":"https://jcunow.github.io/RootScanR/reference/skeletonize_image.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skeletonization Wrapper Function — skeletonize_image","text":"","code":"if (FALSE) { # \\dontrun{ # Load a binary image as a SpatRaster binary_image <- terra::rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0,0), nrow = 3))  # Apply all skeletonization methods skeletons <- skeletonize_image(binary_image, verbose = TRUE) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"Skeletonized root scan image sedge fen northern Finland (June 2023). image processed using RootDetector segmentation skeletonization.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"","code":"data(skl_Oulanka2023_Session01_T067)"},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"RasterBrick object dimensions: 4900 columns (width) 1144 rows (height) 3 layers (channels)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"Binary mask representation : Root skeletons = 1 Background = 0 Layer 1 includes foreign objects (e.g., tape) marked 1 Skeletonization reduces root width single-pixel lines preserving root system topology.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session01_T067.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skeletonized Root Scan - Session 1, Tube 67 — skl_Oulanka2023_Session01_T067","text":"","code":"if (FALSE) { # \\dontrun{   data(skl_Oulanka2023_Session01_T067)   skl_Oulanka2023_Session01_T067 = terra::rast(skl_Oulanka2023_Session01_T067)   terra::plot(skl_Oulanka2023_Session01_T067) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"Skeletonized root scan image sedge fen northern Finland (October 2023). image processed using RootDetector segmentation skeletonization.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"","code":"data(skl_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"RasterBrick object dimensions: 4900 columns (width) 1161 rows (height) 3 layers (channels)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"Binary mask representation : Root skeletons = 1 Background = 0 Layer 1 includes foreign objects (e.g., tape) marked 1 Skeletonization reduces root width single-pixel lines preserving root system topology.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/skl_Oulanka2023_Session03_T067.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skeletonized Root Scan - Session 3, Tube 67 — skl_Oulanka2023_Session03_T067","text":"","code":"if (FALSE) { # \\dontrun{   data(skl_Oulanka2023_Session03_T067)   skl_Oulanka2023_Session03_T067 = terra::rast(skl_Oulanka2023_Session03_T067)   terra::plot(skl_Oulanka2023_Session03_T067) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/stitch_sequential_images.html","id":null,"dir":"Reference","previous_headings":"","what":"Stitch Sequential Images — stitch_sequential_images","title":"Stitch Sequential Images — stitch_sequential_images","text":"function stitches sequence images together aligning overlapping regions based cross-correlation phase-correlation.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/stitch_sequential_images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stitch Sequential Images — stitch_sequential_images","text":"","code":"stitch_sequential_images(   imgs,   overlap_px = 200,   side1 = \"bottom\",   method = \"crosscorr\" )"},{"path":"https://jcunow.github.io/RootScanR/reference/stitch_sequential_images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stitch Sequential Images — stitch_sequential_images","text":"imgs character vector file paths images stitched. overlap_px integer specifying number pixels use search overlap images. Default 200. CI-600 scanner produces 100-200 px overlap 300dpi. side1 string specifying side previous image used overlap (e.g., \"bottom\", \"top\", \"left\", \"right\"). Default \"bottom\". method string specifying method alignment, either \"crosscorr\" \"phasecorr\". Default \"crosscorr\".","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/stitch_sequential_images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stitch Sequential Images — stitch_sequential_images","text":"stitched image cimg object.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/stitch_sequential_images.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stitch Sequential Images — stitch_sequential_images","text":"","code":"if (FALSE) { # \\dontrun{ imgs <- c(\"image1.jpg\", \"image2.jpg\", \"image3.jpg\") stitched <- stitch_sequential_images(imgs = imgs,                     overlap_px = 250, side1 = \"bottom\") } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/supported_formats_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list of supported conversion & input formats as a string — supported_formats_string","title":"Get list of supported conversion & input formats as a string — supported_formats_string","text":"Get list supported conversion & input formats string","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/supported_formats_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list of supported conversion & input formats as a string — supported_formats_string","text":"","code":"supported_formats_string(type = \"Input\")"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weight_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate weights for probability distribution comparison — tail_weight_function","title":"Calculate weights for probability distribution comparison — tail_weight_function","text":"Calculate weights probability distribution comparison","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weight_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate weights for probability distribution comparison — tail_weight_function","text":"","code":"tail_weight_function(   index = NULL,   parameter = list(lambda = 0.2, x0 = 5),   index.spacing = \"equal\",   method = \"sigmoid\",   baseline.weight = 0,   inverse = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weight_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate weights for probability distribution comparison — tail_weight_function","text":"index Numeric vector specifying positions weight calculation parameter List containing: - lambda: Shape parameter (0 = constant weighting) - x0: Curve offset/inflection point index.spacing Character, either \"equal\" \"custom\" index spacing type method Character, weighting function type: \"constant\", \"asymptotic\", \"linear\", \"exponential\", \"sigmoid\", \"gompertz\", \"step\" baseline.weight Numeric 0-1, minimum weight value inverse Logical, TRUE reverses weight distribution (left vs right tail)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weight_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate weights for probability distribution comparison — tail_weight_function","text":"Normalized weight vector","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_js_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","title":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"Calculate tail-weighted Jensen-Shannon divergence","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_js_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"","code":"tail_weighted_js_divergence(   P,   Q,   parameter = list(lambda = 0.2, x0 = 30),   method = \"constant\",   inverse = FALSE,   alignPQ = TRUE,   cut = FALSE,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\" )"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_js_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"P probability vector 2 Q probability vector 1 parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") inverse changes right tail left tail TRUE alignPQ TRUE, index end values cut case unequal length P & Q length P & Q equal cut FALSE, 0 added shorter vector. TRUE, longer vector shortened end. index positive numeric vector containing probability spacing e.g., depth index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_js_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"Numeric JS divergence value","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_js_divergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"","code":"P <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)  # Distribution P Q <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)**6  # Distribution Q  # Ensure the distributions are valid (non-negative and sum to 1) P <- P / sum(P) Q <- Q / sum(Q)  tail_weighted_js_divergence(P,Q,parameter = list(lambda = 0.2,x0=30)) #> [1] 0.197"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_kl_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"Calculate tail-weighted KL divergence discrete distributions","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_kl_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"","code":"tail_weighted_kl_divergence(   P,   Q,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\",   parameter = list(lambda = 0.2, x0 = 30),   cut = FALSE,   inverse = FALSE,   method = \"constant\",   alignPQ = TRUE )"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_kl_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"P probability vector 2 Q probability vector 1 index positive numeric vector containing probability spacing e.g., depth index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n) parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) cut FALSE, 0 added shorter vector. TRUE, longer vector shortened end. inverse changes right tail left tail TRUE method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") alignPQ TRUE, index end values cut case unequal length P & Q length P & Q equal","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_kl_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"KL divergence, symmetrical - changing input order change result","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_kl_divergence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"Kullback-Leibler Divergence","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_wasserstein_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"tailweighted Version 1 dimensional Wasserstein distance betwwen two probability vectors","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_wasserstein_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"","code":"tail_weighted_wasserstein_distance(   Q,   P,   inverse = FALSE,   parameter = list(lambda = 0.2, x0 = 10),   method = \"step\",   baseline.weight = 0,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\" )"},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_wasserstein_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"Q probability vector 1 P probability vector 2 inverse changes right tail left tail TRUE parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") baseline.weight Numeric 0-1 index positive numeric vector containing probability spacing e.g., depth index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_wasserstein_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"Numeric Wasserstein distance","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tail_weighted_wasserstein_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"","code":"P <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)  # Distribution P Q <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)**6  # Distribution Q  # Ensure the distributions are valid (non-negative and sum to 1) P <- P / sum(P) Q <- Q / sum(Q)  tail_weighted_wasserstein_distance(P,Q,   inverse=FALSE,method=\"constant\",parameter = list(lambda = 0.2,x0=3)) #> [1] 0.1008476"},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":null,"dir":"Reference","previous_headings":"","what":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"internal function applies Guo-Hall thinning algorithm reduce binary images skeletons preserving connectivity structure.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"","code":"thin_image_guohall(img, verbose = FALSE, select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"img matrix, data frame, `SpatRaster` object representing binary image thinned. verbose Logical. `TRUE`, outputs diagnostic information image dimensions, pixel removal counts, iteration progress. Default `FALSE`. select.layer Integer indicating layer use `img` multi-layer `SpatRaster`. Default 2.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"binary matrix representing thinned image (skeleton).","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"- input image first processed using load_flexible_image ensure binary matrix. - Thinning performed iterative process consisting two subiterations per cycle:   1. first subiteration, pixels marked removal based specific Guo-Hall conditions.   2. second subiteration, different set conditions applied mark additional pixels removal. - process continues pixels removed iteration maximum number iterations (default: 1000) reached. - Guo-Hall algorithm ensures skeleton image preserved.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_guohall.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enhanced Guo-Hall Thinning Algorithm Thin Binary Image using Guo-Hall Algorithm (Internal) — thin_image_guohall","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage raster <- terra::rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0,0), nrow = 3)) thinned_image <- thin_image_guohall(raster, verbose = TRUE) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":null,"dir":"Reference","previous_headings":"","what":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"internal function performs image thinning using Zhang-Suen thinning algorithm. reduces binary images skeleton preserving structure connectivity foreground pixels.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"","code":"thin_image_zhangsuen(img, verbose = TRUE, select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"img matrix, data frame, `SpatRaster` object representing binary image thinned. verbose Logical. `TRUE`, prints diagnostic information iteration progress pixel removal counts. Default `TRUE`. select.layer Integer indicating layer use `img` multi-layer `SpatRaster`. Default 2.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"binary matrix representing thinned image (skeleton).","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"- function first prepares image using load_flexible_image function, ensuring binary matrix format. - Thinning performed iteratively two subiterations per cycle:   1. Identifying pixels removed based Zhang-Suen conditions (first subiteration).   2. Refining removal decisions second subiteration. - algorithm continues pixels removed iteration maximum number iterations reached (default: 1000).","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/thin_image_zhangsuen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thin Binary Image using Zhang-Suen Algorithm (Internal) — thin_image_zhangsuen","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage raster <- terra::rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0,0), nrow = 3)) thinned_image <- thin_image_zhangsuen(raster, verbose = TRUE, select.layer = NULL) } # }"},{"path":"https://jcunow.github.io/RootScanR/reference/tube_coloration.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Image Coloration Metrics — tube_coloration","title":"Calculate Image Coloration Metrics — tube_coloration","text":"Calculate Image Coloration Metrics","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tube_coloration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Image Coloration Metrics — tube_coloration","text":"","code":"tube_coloration(img, r = 0.2126, g = 0.7152, b = 0.0722)"},{"path":"https://jcunow.github.io/RootScanR/reference/tube_coloration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Image Coloration Metrics — tube_coloration","text":"img Three-band raster (RGB) path image r Red channel weight g Green channel weight b Blue channel weight","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tube_coloration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Image Coloration Metrics — tube_coloration","text":"Data frame color metrics","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/tube_coloration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Image Coloration Metrics — tube_coloration","text":"","code":"data(rgb_Oulanka2023_Session03_T067) img = terra::rast(rgb_Oulanka2023_Session03_T067) colorvector = tube_coloration(img) #> Some pixels have zero intensity, which may affect color calculations"},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_dpc.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","title":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","text":"Extract Root Decay, New Root Production, -Change Roots ('RootDetector' images)","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_dpc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","text":"","code":"turnover_dpc(   img,   product.layer = 2,   decay.layer = 1,   blur.capture = 0.95,   im.return = FALSE,   include.virtualroots = FALSE )"},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_dpc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","text":"img SpatRaster three layers production, decay, stagnation product.layer Integer indicating production layer index (1-3) decay.layer Integer indicating decay & tape layer index (1-3) blur.capture Threshold pixel inclusion (0-1). Default: 0.95 im.return Logical: return images instead values? Default: FALSE include.virtualroots Logical: consider roots present timepoint? Default: FALSE","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_dpc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","text":"im.return = FALSE: tibble pixel sums ratios         im.return = TRUE: list SpatRaster layers tape, constant, production, decay","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_dpc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Root Decay, New Root Production, and No-Change Roots (only 'RootDetector' images) — turnover_dpc","text":"","code":"data(TurnoverDPC_data) img = terra::rast(TurnoverDPC_data) DPCs = turnover_dpc(img = img, im.return = FALSE)"},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_tc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate global root production and root turnover from temporal comparison — turnover_tc","title":"Calculate global root production and root turnover from temporal comparison — turnover_tc","text":"Calculate global root production root turnover temporal comparison","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_tc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate global root production and root turnover from temporal comparison — turnover_tc","text":"","code":"turnover_tc(   im.t1,   im.t2,   method = \"kimura\",   unit = \"cm\",   dpi = 300,   select.layer = 2 )"},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_tc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate global root production and root turnover from temporal comparison — turnover_tc","text":"im.t1 SpatRaster object timepoint 1 im.t2 SpatRaster object timepoint 2 method Analysis method: \"kimura\" \"rootpx\" unit Unit root length measurement (method = \"kimura\"). Default: \"cm\" dpi Image resolution (method = \"kimura\"). Default: 300 select.layer Integer specifying layer use timesteps img multi-layer `SpatRaster`. Defaults 2.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_tc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate global root production and root turnover from temporal comparison — turnover_tc","text":"data.frame containing:   - standingroot_t1: Standing roots first timepoint   - standingroot_t2: Standing roots second timepoint   - production: Root production timepoints   - newroot   - newroot","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/turnover_tc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate global root production and root turnover from temporal comparison — turnover_tc","text":"","code":"data(skl_Oulanka2023_Session01_T067)   data(skl_Oulanka2023_Session03_T067)   time1 <- terra::rast(skl_Oulanka2023_Session01_T067)   time2 <- terra::rast(skl_Oulanka2023_Session03_T067)   turnover.values <- turnover_tc(     im.t1 = time1,     im.t2 = time2,     method = \"kimura\")"},{"path":"https://jcunow.github.io/RootScanR/reference/validate_conversion_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate conversion parameters — validate_conversion_params","title":"Validate conversion parameters — validate_conversion_params","text":"Validate conversion parameters","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/validate_conversion_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate conversion parameters — validate_conversion_params","text":"","code":"validate_conversion_params(input, normalize, select.layer, binarize)"},{"path":"https://jcunow.github.io/RootScanR/reference/validate_image_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Image Input Parameters — validate_image_input","title":"Validate Image Input Parameters — validate_image_input","text":"Internal function validate input parameters image processing functions Used image skeletonizing","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/validate_image_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Image Input Parameters — validate_image_input","text":"","code":"validate_image_input(   img,   allow_empty = FALSE,   min_dim = c(3, 3),   require_binary = TRUE,   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/validate_image_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Image Input Parameters — validate_image_input","text":"img input image validate allow_empty Logical, whether allow empty images min_dim Minimum required dimensions require_binary Logical, whether require binary values select.layer Layer validate multi-layer images","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/validate_image_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Image Input Parameters — validate_image_input","text":"List containing validated processed image data","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/validate_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to validate inputs — validate_inputs","title":"Helper function to validate inputs — validate_inputs","text":"Helper function validate inputs","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/validate_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to validate inputs — validate_inputs","text":"","code":"validate_inputs(tt, yy, period, parStart = NULL, beta = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/zone.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a zone of interest based on depth values — zone.fun","title":"Extract a zone of interest based on depth values — zone.fun","text":"Extract zone interest based depth values","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a zone of interest based on depth values — zone.fun","text":"","code":"zone.fun(rootpic, binned.map, indexD = 0, silent = FALSE, select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/zone.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a zone of interest based on depth values — zone.fun","text":"rootpic SpatRaster/matrix/array - source image binned.map SpatRaster/matrix/array - binned depth map indexD numeric - depth index extract. Usually used index loop iterate depths. silent logical - suppress messages select.layer Integer. Specifies layer use input multi-band image. Default `2`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a zone of interest based on depth values — zone.fun","text":"SpatRaster - extracted zone","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a zone of interest based on depth values — zone.fun","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) mask = img[[1]] - img[[2]] mask[mask == 255] <- NA img = img depthmap = create_depthmap(img,mask,start.soil = 2.9, select.layer = 2 ) #> Processing row 100 of 4900 #> Processing row 200 of 4900 #> Processing row 300 of 4900 #> Processing row 400 of 4900 #> Processing row 500 of 4900 #> Processing row 600 of 4900 #> Processing row 700 of 4900 #> Processing row 800 of 4900 #> Processing row 900 of 4900 #> Processing row 1000 of 4900 #> Processing row 1100 of 4900 #> Processing row 1200 of 4900 #> Processing row 1300 of 4900 #> Processing row 1400 of 4900 #> Processing row 1500 of 4900 #> Processing row 1600 of 4900 #> Processing row 1700 of 4900 #> Processing row 1800 of 4900 #> Processing row 1900 of 4900 #> Processing row 2000 of 4900 #> Processing row 2100 of 4900 #> Processing row 2200 of 4900 #> Processing row 2300 of 4900 #> Processing row 2400 of 4900 #> Processing row 2500 of 4900 #> Processing row 2600 of 4900 #> Processing row 2700 of 4900 #> Processing row 2800 of 4900 #> Processing row 2900 of 4900 #> Processing row 3000 of 4900 #> Processing row 3100 of 4900 #> Processing row 3200 of 4900 #> Processing row 3300 of 4900 #> Processing row 3400 of 4900 #> Processing row 3500 of 4900 #> Processing row 3600 of 4900 #> Processing row 3700 of 4900 #> Processing row 3800 of 4900 #> Processing row 3900 of 4900 #> Processing row 4000 of 4900 #> Processing row 4100 of 4900 #> Processing row 4200 of 4900 #> Processing row 4300 of 4900 #> Processing row 4400 of 4900 #> Processing row 4500 of 4900 #> Processing row 4600 of 4900 #> Processing row 4700 of 4900 #> Processing row 4800 of 4900 #> Processing row 4900 of 4900 binned.map = binning(depthmap,nn = 5)  data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) mask = img[[1]] - img[[2]] mask[mask == 255] <- NA depthmap = create_depthmap(img,mask,start.soil = 0, tube.thicc = 7,dpi = 150, select.layer = 2 ) #> Processing row 100 of 4900 #> Processing row 200 of 4900 #> Processing row 300 of 4900 #> Processing row 400 of 4900 #> Processing row 500 of 4900 #> Processing row 600 of 4900 #> Processing row 700 of 4900 #> Processing row 800 of 4900 #> Processing row 900 of 4900 #> Processing row 1000 of 4900 #> Processing row 1100 of 4900 #> Processing row 1200 of 4900 #> Processing row 1300 of 4900 #> Processing row 1400 of 4900 #> Processing row 1500 of 4900 #> Processing row 1600 of 4900 #> Processing row 1700 of 4900 #> Processing row 1800 of 4900 #> Processing row 1900 of 4900 #> Processing row 2000 of 4900 #> Processing row 2100 of 4900 #> Processing row 2200 of 4900 #> Processing row 2300 of 4900 #> Processing row 2400 of 4900 #> Processing row 2500 of 4900 #> Processing row 2600 of 4900 #> Processing row 2700 of 4900 #> Processing row 2800 of 4900 #> Processing row 2900 of 4900 #> Processing row 3000 of 4900 #> Processing row 3100 of 4900 #> Processing row 3200 of 4900 #> Processing row 3300 of 4900 #> Processing row 3400 of 4900 #> Processing row 3500 of 4900 #> Processing row 3600 of 4900 #> Processing row 3700 of 4900 #> Processing row 3800 of 4900 #> Processing row 3900 of 4900 #> Processing row 4000 of 4900 #> Processing row 4100 of 4900 #> Processing row 4200 of 4900 #> Processing row 4300 of 4900 #> Processing row 4400 of 4900 #> Processing row 4500 of 4900 #> Processing row 4600 of 4900 #> Processing row 4700 of 4900 #> Processing row 4800 of 4900 #> Processing row 4900 of 4900 binned.map = binning(depthmap,nn = 5) image.zone = zone.fun(img, binned.map, indexD = 10,  silent = FALSE,select.layer = NULL)"},{"path":"https://jcunow.github.io/RootScanR/reference/zone.rotation.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract zones based on rotation axis — zone.rotation.fun","title":"Extract zones based on rotation axis — zone.rotation.fun","text":"Extract zones based rotation axis","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.rotation.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract zones based on rotation axis — zone.rotation.fun","text":"","code":"zone.rotation.fun(   img,   k = c(3, 4),   kk = 5,   mm = c(2000, 4000),   select.layer = NULL )"},{"path":"https://jcunow.github.io/RootScanR/reference/zone.rotation.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract zones based on rotation axis — zone.rotation.fun","text":"img array/matrix/SpatRaster - source image k numeric vector - cuts keep (length 2) kk numeric - total number cuts mm numeric vector - region limits (length 2) select.layer Integer. Specifies layer use input multi-band image. Default `NULL`.","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.rotation.fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract zones based on rotation axis — zone.rotation.fun","text":"SpatRaster - extracted rotation zone","code":""},{"path":"https://jcunow.github.io/RootScanR/reference/zone.rotation.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract zones based on rotation axis — zone.rotation.fun","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) rotationZone = zone.rotation.fun(img, k = c(1,2), kk = 7, mm = c(1500,3000))"},{"path":"https://jcunow.github.io/RootScanR/news/index.html","id":"rootscanr-100","dir":"Changelog","previous_headings":"","what":"RootScanR 1.0.0","title":"RootScanR 1.0.0","text":"Initial CRAN submission.","code":""}]
