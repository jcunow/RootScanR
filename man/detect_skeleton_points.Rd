% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Thinning3.R
\name{detect_skeleton_points}
\alias{detect_skeleton_points}
\title{Detect Skeleton Points: Branching Points and Endpoints}
\usage{
detect_skeleton_points(img, select.layer = 2)
}
\arguments{
\item{img}{A matrix, data frame, or `SpatRaster` object representing the skeletonized binary image.}

\item{select.layer}{Integer. Specifies which layer to use if the input is a multi-band image. Default is `2`.}
}
\value{
A named list containing two `SpatRaster` objects:
\itemize{
  \item \code{endpoints}: A binary raster where endpoints are marked as \code{1}.
  \item \code{branching_points}: A binary raster where branching points are marked as \code{1}.
}
}
\description{
Identifies the branching points and endpoints of a skeletonized binary image.
}
\details{
This function detects key points in a skeletonized binary image:
\itemize{
  \item \strong{Endpoints}: Pixels with exactly one neighbor in the skeleton.
  \item \strong{Branching Points}: Pixels with more than two neighbors in the skeleton.
}

The function uses a 3x3 neighborhood kernel to count the number of neighbors for each foreground pixel (\code{1}) in the image. Based on the neighbor count, points are classified as endpoints or branching points.

The input image should be skeletonized (thin and connected) before using this function. If not already binary, the input image will be binarized internally.
}
\examples{
\dontrun{
library(terra)

# Example skeletonized image
skeleton <- rast(matrix(c(0, 1, 1, 0, 0, 1, 1, 0), nrow = 4))

# Detect endpoints and branching points
points <- detect_skeleton_points(skeleton)

# Access results
endpoints <- points$endpoints
branching_points <- points$branching_points
}

}
\seealso{
\code{\link{skeletonize_image}}, \code{\link{thin_image_zhangsuen}}, \code{\link{thin_image_guohall}}
}
